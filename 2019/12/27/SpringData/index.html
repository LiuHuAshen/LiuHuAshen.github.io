<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="SpringData"/><meta name="keywords" content="前端,开发者,程序猿,Coder" /><link rel="alternate" href="/default" title="LHS'Blogs"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://LiuHuAshen.github.io/2019/12/27/SpringData/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>SpringData - LHS'Blogs</title>
  <meta name="generator" content="Hexo 4.2.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">LHS'Blogs</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">LHS'Blogs</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">SpringData
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-12-27
        </span></div>
    </header>

    <div class="post-content"><p>Spring Data :Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。</p>
<p>SpringData 项目所支持 NoSQL 存储：</p>
<ul>
<li>MongoDB （文档数据库）</li>
<li>Neo4j（图形数据库）</li>
<li>Redis（键/值存储）</li>
<li>Hbase（列族数据库）</li>
</ul>
<p>SpringData 项目所支持的关系数据存储技术：</p>
<ul>
<li>JDBC</li>
<li>JPA</li>
<li>JPA Spring Data 概述</li>
<li>JPA Spring Data : 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</li>
</ul>
<p>框架怎么可能代替开发者实现业务逻辑呢？</p>
<p>比如：当有一个 UserDao.findUserById() 这样一个方法声明，我们大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象，框架根据方法名也知道要做什么，Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p>
<p>SpringData JPA HelloWorld<br>使用 Spring Data JPA 进行持久层开发需要的四个步骤：</p>
<p>配置 Spring 整合 JPA<br>笔记使用的是SpringBoot配置，配置不重要，重要的是核心内容。</p>
<p>如果使用SpringBoot配置如下：只需要导入依赖并且填写application.yml文件即可</p>
<a id="more"></a>
<p>依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringDataJPA的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;!--MySQL驱动的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;root</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springdatajpa?serverTimezone&#x3D;Asia&#x2F;Shanghai</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.jpa.hibernate.ddl-auto&#x3D;update</span><br><span class="line">spring.jpa.generate-ddl&#x3D;true</span><br><span class="line">spring.jpa.show-sql&#x3D;true</span><br><span class="line">spring.jpa.database-platform&#x3D;org.hibernate.dialect.MySQL8Dialect</span><br></pre></td></tr></table></figure>
<p>注意，如果配置文件中不添加：</p>
<p>spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect</p>
<p>则会造成下面的情况，注意下面的SQL语句创建的是MyISAM引擎的数据表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table cst_customer (cust_id bigint not null auto_increment, cust_address varchar(255), cust_industry varchar(255), cust_level varchar(255), cust_name varchar(255), cust_phone varchar(255), cust_source varchar(255), primary key (cust_id)) engine&#x3D;MyISAM</span><br></pre></td></tr></table></figure>


<p>添加spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect后，就变成了InnoDB引擎:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table cst_customer (cust_id bigint not null auto_increment, cust_address varchar(255), cust_industry varchar(255), cust_level varchar(255), cust_name varchar(255), cust_phone varchar(255), cust_source varchar(255), primary key (cust_id)) engine&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>spring.jpa.database-platform配置的是数据库的方言</p>
<p>以下是原生方式搭建SpringDataJPA，可以跳到开始开发</p>
<p>如果使用默认的Spring配置文件的方式，需要先掌握一些JPA的配置规范，百度上到处都有教程，大致步骤如下：</p>
<p>搭建环境：</p>
<p>同时下载 Spring Data Commons 和 Spring Data JPA 两个发布包：<br>Commons 是 Spring Data 的基础包<br>并把相关的依赖 JAR 文件加入到 CLASSPATH 中</p>
<p>在Spring 配置文件中配置 Spring Data，让 Spring为声明的接口创建代理对象。配置了<a href="jpa:repositories">jpa:repositories</a>后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring自动封装的特性来直接使用该对象。</p>
<p>声明持久层的接口，该接口继承 Repository，Repository是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口（通常我们也是实现其他接口），其中定义了一些常用的增删改查，以及分页相关的方法。</p>
<p>在接口中声明需要的方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</p>
<p>开始开发<br>写一个实体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.example.application.model;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import javax.persistence.*;</span><br><span class="line">@Entity</span><br><span class="line">@Table(name &#x3D; &quot;cst_customer&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Customer &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy &#x3D; GenerationType.IDENTITY)</span><br><span class="line">    @Column(name &#x3D; &quot;cust_id&quot;)</span><br><span class="line">    private Long custId;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_address&quot;)</span><br><span class="line">    private String custAddress;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_industry&quot;)</span><br><span class="line">    private String custIndustry;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_level&quot;)</span><br><span class="line">    private String custLevel;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_name&quot;)</span><br><span class="line">    private String custName;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_phone&quot;)</span><br><span class="line">    private String custPhone;</span><br><span class="line">    @Column(name &#x3D; &quot;cust_source&quot;)</span><br><span class="line">    private String custSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个实体类使用了Lombok</p>
<p>类上面的注解解释</p>
<p>@Entity: 标识该实体类是一个JPA实体类</p>
<p>@Table: 用来规定该实体类在数据库中所对应的的表的一些特性</p>
<p>@Data:Lombok注解用来生成getter，setter，toString，hashCode，equals等方法</p>
<p>@Id:标识该字段为数据表记录中的Id字段</p>
<p>@GeneratedValue:主见的生成策略，上面的strategy = GenerationType.IDENTITY意思是使用主键自增的方式来控制主键</p>
<p>@Column:用来映射该属性和数据表中字段名</p>
<p>写一个Repository接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.example.application.repository;</span><br><span class="line">import com.example.application.model.Customer;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面的Repository接口继承了两个接口JpaRepository和JpaSpecificationExecutor</p>
<p>这两个接口中都定义了很多的方法，接口上要规定泛型</p>
<p>T：表示该Repository要操作的实体类的类型</p>
<p>ID：表示该Repository控制的实体类的ID是什么类型</p>
<p>Repository接口的解释<br>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.repository;</span><br><span class="line">import org.springframework.stereotype.Indexed;</span><br><span class="line">@Indexed</span><br><span class="line">public interface Repository&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Spring Data可以让我们只定义接口，只要遵循 Spring Data的规范，就无需写实现类。</p>
<p>与继承Repository等价的一种方式，就是在持久层接口上使用@RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。</p>
<p>Repository的子接口<br>基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。</p>
<p>它们的继承关系如下： Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类 CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。 JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</p>
<p>SpringDataJPA的方法定义规范<br>简单条件查询: 查询某一个实体类或者集合</p>
<p>按照 Spring Data 的规范，查询方法以 find | read | get开头， 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。</p>
<p>例如：定义一个 Entity 实体类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">	private String firstName;</span><br><span class="line">	private String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用And条件连接时，应这样写：</p>
<p>findByLastNameAndFirstName(String lastName,String firstName);</p>
<p>条件的属性名称与个数要与参数的位置与个数一一对应</p>
<p>直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：</p>
<p>支持的查询关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Logical keyword	Keyword expressions</span><br><span class="line">AND	And</span><br><span class="line">OR	Or</span><br><span class="line">AFTER	After, IsAfter</span><br><span class="line">BEFORE	Before, IsBefore</span><br><span class="line">CONTAINING	Containing, IsContaining, Contains</span><br><span class="line">BETWEEN	Between, IsBetween</span><br><span class="line">ENDING_WITH	EndingWith, IsEndingWith, EndsWith</span><br><span class="line">EXISTS	Exists</span><br><span class="line">FALSE	False, IsFalse</span><br><span class="line">GREATER_THAN	GreaterThan, IsGreaterThan</span><br><span class="line">GREATER_THAN_EQUALS	GreaterThanEqual, IsGreaterThanEqual</span><br><span class="line">IN	In, IsIn</span><br><span class="line">IS	Is, Equals, (or no keyword)</span><br><span class="line">IS_EMPTY	IsEmpty, Empty</span><br><span class="line">IS_NOT_EMPTY	IsNotEmpty, NotEmpty</span><br><span class="line">IS_NOT_NULL	NotNull, IsNotNull</span><br><span class="line">IS_NULL	Null, IsNull</span><br><span class="line">LESS_THAN	LessThan, IsLessThan</span><br><span class="line">LESS_THAN_EQUAL	LessThanEqual, IsLessThanEqual</span><br><span class="line">LIKE	Like, IsLike</span><br><span class="line">NEAR	Near, IsNear</span><br><span class="line">NOT	Not, IsNot</span><br><span class="line">NOT_IN	NotIn, IsNotIn</span><br><span class="line">NOT_LIKE	NotLike, IsNotLike</span><br><span class="line">REGEX	Regex, MatchesRegex, Matches</span><br><span class="line">STARTING_WITH	StartingWith, IsStartingWith, StartsWith</span><br><span class="line">TRUE	True, IsTrue</span><br><span class="line">WITHIN	Within, IsWithin</span><br></pre></td></tr></table></figure>

<p>SpringDataJPA对查询关键字的解析步骤<br>假如创建如下的查询：</p>
<p>findByUserDepUuid();</p>
<p>框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</p>
<p>从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；</p>
<p>接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。</p>
<p>可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()” 特殊的参数： 还可以直接在方法的参数上加入分页或排序的参数，比如：</p>
<p>Page<UserModel> findByName(String name, Pageable pageable);<br>List<UserModel> findByName(String name, Sort sort);</p>
<p>使用 @Query 注解<br>这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。</p>
<p>上面的代码使用的是JPQL语法，下面会说。</p>
<p>上面的?1是一个参数占位符，对于参数占位符来说，有索引参数和命名参数</p>
<p>索引参数如上所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致</p>
<p>命名参数（推荐使用这种方式）：可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序。</p>
<p>如果是@Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select o from UserModel o where o.name like ?1%&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br><span class="line">@Query(&quot;select o from UserModel o where o.name like %?1&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br><span class="line">@Query(&quot;select o from UserModel o where o.name like %?1%&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br></pre></td></tr></table></figure>

<p>重点：还可以使用@Query来指定本地查询，只要设置nativeQuery为true，比如：</p>
<p>@Query(value=”select * from tbl_user where name like %?1” ,nativeQuery=true)<br>public List<UserModel> findByUuidOrAge(String name);</p>
<p>@Modifying 注解和事务<br>@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如只涉及某些字段更新时最为常用，示例如下：</p>
<p>注意： 方法的返回值应该是 int，表示更新语句所影响的行数 在调用的地方必须加事务，没有事务不能正常执行</p>
<p>事务<br>Spring Data提供了默认的事务处理方式，即所有的查询均声明为只读事务。</p>
<p>对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上注解 @Transactional 声明</p>
<p>进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在 Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。</p>
<p>对于Repository接口的具体说明<br>CrudRepository 接口提供了最基本的对实体类的添删改查操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">T save(T entity);&#x2F;&#x2F;保存单个实体</span><br><span class="line">Iterable save(Iterable&lt;? extends T&gt; entities);&#x2F;&#x2F;保存集合</span><br><span class="line">T findOne(ID id);&#x2F;&#x2F;根据id查找实体</span><br><span class="line">boolean exists(ID id);&#x2F;&#x2F;根据id判断实体是否存在</span><br><span class="line">Iterable findAll();&#x2F;&#x2F;查询所有实体,不用或慎用!</span><br><span class="line">long count();&#x2F;&#x2F;查询实体数量</span><br><span class="line">void delete(ID id);&#x2F;&#x2F;根据Id删除实体</span><br><span class="line">void delete(T entity);&#x2F;&#x2F;删除一个实体</span><br><span class="line">void delete(Iterable&lt;? extends T&gt; entities);&#x2F;&#x2F;删除一个实体的集合</span><br><span class="line">void deleteAll();&#x2F;&#x2F;删除所有实体,不用或慎用!</span><br><span class="line">PagingAndSortingRepository接口提供了分页与排序功能</span><br><span class="line"></span><br><span class="line">Iterable findAll(Sort sort); &#x2F;&#x2F;排序</span><br><span class="line">Page findAll(Pageable pageable); &#x2F;&#x2F;分页查询（含排序功能）</span><br><span class="line">JpaRepository接口提供了JPA的相关功能</span><br><span class="line"></span><br><span class="line">List findAll(); &#x2F;&#x2F;查找所有实体</span><br><span class="line">List findAll(Sort sort); &#x2F;&#x2F;排序、查找所有实体</span><br><span class="line">List save(Iterable&lt;? extends T&gt; entities);&#x2F;&#x2F;保存集合</span><br><span class="line">void flush();&#x2F;&#x2F;执行缓存与数据库同步</span><br><span class="line">T saveAndFlush(T entity);&#x2F;&#x2F;强制执行持久化</span><br><span class="line">void deleteInBatch(Iterable entities);&#x2F;&#x2F;删除一个实体集合</span><br><span class="line">JpaSpecificationExecutor接口</span><br><span class="line"></span><br><span class="line">不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</span><br><span class="line"></span><br><span class="line">public interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">	Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">	List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">	Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">	List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">	long count(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Specification：封装 JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象，Specification接口中有一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);</span><br></pre></td></tr></table></figure>
<p>其中的root是用来进行属性导航的，比如说实体类中有一个属性是username，用root来导航到这个username，需要像下面这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.get(&quot;username&quot;).as(String.class);</span><br></pre></td></tr></table></figure>



<p>JPQL查询语法<br>假设有一个实体类User，实体类中有两个属性username和password</p>
<p>查询全部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from User;</span><br></pre></td></tr></table></figure>


<p>查询结果按照username倒序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from User order by username desc;</span><br></pre></td></tr></table></figure>

<p>统计查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(username) from User;</span><br></pre></td></tr></table></figure>

<p>分页和条件查询:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT DISTINCT u FROM User u where u.username &#x3D; ?1&quot;)</span><br><span class="line">public List&lt;User&gt; findByUsername(String username, Pageable pageable);</span><br></pre></td></tr></table></figure>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://LiuHuAshen.github.io">LHS</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://liuhuashen.github.io/2019/12/27/SpringData/">https://liuhuashen.github.io/2019/12/27/SpringData/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/SpringData/">SpringData</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2019/12/27/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Redis为什么那么快？</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2019/12/27/java%E8%BF%9E%E6%8E%A5redis%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98/">
        <span class="next-text nav-default">java连接redis不成功的问题</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/ahonn" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">LHS</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
