<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LHS&#39;Blogs</title>
  <icon>https://www.gravatar.com/avatar/1113dea67b03ac77ab892e6f7cacd06c</icon>
  <subtitle>欢迎参观我的博客</subtitle>
  <link href="https://liuhuashen.github.io/atom.xml" rel="self"/>
  
  <link href="https://liuhuashen.github.io/"/>
  <updated>2021-07-03T07:38:59.974Z</updated>
  <id>https://liuhuashen.github.io/</id>
  
  <author>
    <name>LHS</name>
    <email>318231325@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ElasticSearch</title>
    <link href="https://liuhuashen.github.io/2021/06/20/ElasticSearch/"/>
    <id>https://liuhuashen.github.io/2021/06/20/ElasticSearch/</id>
    <published>2021-06-20T01:35:56.000Z</published>
    <updated>2021-07-03T07:38:59.974Z</updated>
    
    <content type="html"><![CDATA[<p>Elasticsearch 是一个实时的分布式搜索分析引擎，解决问题：</p><p>1、自动维护数据的分布到多个节点的索引的建立，还有搜索请求分布到多个节点的执行</p><p>2、自动维护数据的冗余副本，保证了一旦机器宕机，不会丢失数据</p><p>3、封装了更多高级的功能，例如聚合分析的功能，基于地理位置的搜索</p><a id="more"></a><p><strong>功能</strong></p><ol><li>分布式的搜索引擎和数据分析引擎<br>搜索：网站的站内搜索，IT系统的检索</li></ol><p>数据分析：电商网站，统计销售排名前10的商家</p><ol start="2"><li>全文检索，结构化检索，数据分析<br>全文检索：我想搜索商品名称包含某个关键字的商品</li></ol><p>结构化检索：我想搜索商品分类为日化用品的商品都有哪些</p><p>数据分析：我们分析每一个商品分类下有多少个商品</p><ol start="3"><li>对海量数据进行近实时的处理<br>分布式：ES自动可以将海量数据分散到多台服务器上去存储和检索</li></ol><p>海联数据的处理：分布式以后，就可以采用大量的服务器去存储和检索数据，自然而然就可以实现海量数据的处理了</p><p>近实时：检索数据要花费1小时（这就不要近实时，离线批处理，batch-processing）；在秒级别对数据进行搜索和分析</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Elasticsearch 是一个实时的分布式搜索分析引擎，解决问题：&lt;/p&gt;
&lt;p&gt;1、自动维护数据的分布到多个节点的索引的建立，还有搜索请求分布到多个节点的执行&lt;/p&gt;
&lt;p&gt;2、自动维护数据的冗余副本，保证了一旦机器宕机，不会丢失数据&lt;/p&gt;
&lt;p&gt;3、封装了更多高级的功能，例如聚合分析的功能，基于地理位置的搜索&lt;/p&gt;</summary>
    
    
    
    
    <category term="ElasticSearch" scheme="https://LiuHuAshen.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>URL化及数组重排</title>
    <link href="https://liuhuashen.github.io/2021/03/09/URL%E5%8C%96%E5%8F%8A%E6%95%B0%E7%BB%84%E9%87%8D%E6%8E%92/"/>
    <id>https://liuhuashen.github.io/2021/03/09/URL%E5%8C%96%E5%8F%8A%E6%95%B0%E7%BB%84%E9%87%8D%E6%8E%92/</id>
    <published>2021-03-09T01:48:44.000Z</published>
    <updated>2021-03-09T01:55:14.450Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-url-lcci/" target="_blank" rel="noopener">URL化</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">' '</span>)&#123;</span><br><span class="line">              sb.append(<span class="string">"%20"</span>);</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/shuffle-string/" target="_blank" rel="noopener">重新排列字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">restoreString</span><span class="params">(String s, <span class="keyword">int</span>[] indices)</span> </span>&#123;</span><br><span class="line">      StringBuilder sb=<span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;indices.length;i++)&#123;</span><br><span class="line">        sb.setCharAt(indices[i],s.charAt(i));</span><br><span class="line">      &#125;</span><br><span class="line">      String ans=<span class="keyword">new</span> String(sb);</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/string-to-url-lcci/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;URL化&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;</summary>
      
    
    
    
    
    <category term="每日算法" scheme="https://LiuHuAshen.github.io/tags/每日算法/"/>
    
  </entry>
  
  <entry>
    <title>leetcode题解——数学</title>
    <link href="https://liuhuashen.github.io/2020/10/22/leetcode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6/"/>
    <id>https://liuhuashen.github.io/2020/10/22/leetcode%E9%A2%98%E8%A7%A3%E2%80%94%E2%80%94%E6%95%B0%E5%AD%A6/</id>
    <published>2020-10-22T02:41:34.000Z</published>
    <updated>2021-07-03T07:39:22.607Z</updated>
    
    <content type="html"><![CDATA[<!-- GFM-TOC --><ul><li><a href="#素数分解">素数分解</a></li><li><a href="#整除">整除</a></li><li><a href="#最大公约数最小公倍数">最大公约数最小公倍数</a><ul><li><a href="#1-生成素数序列">1. 生成素数序列</a></li><li><a href="#2-最大公约数">2. 最大公约数</a></li><li><a href="#3-使用位操作和减法求解最大公约数">3. 使用位操作和减法求解最大公约数</a></li></ul></li><li><a href="#进制转换">进制转换</a><ul><li><a href="#1-7-进制">1. 7 进制</a></li><li><a href="#2-16-进制">2. 16 进制</a></li><li><a href="#3-26-进制">3. 26 进制</a></li></ul></li><li><a href="#阶乘">阶乘</a><ul><li><a href="#1-统计阶乘尾部有多少个-0">1. 统计阶乘尾部有多少个 0</a></li></ul></li><li><a href="#字符串加法减法">字符串加法减法</a><ul><li><a href="#1-二进制加法">1. 二进制加法</a></li><li><a href="#2-字符串加法">2. 字符串加法</a></li></ul></li><li><a href="#相遇问题">相遇问题</a><ul><li><a href="#1-改变数组元素使所有的数组元素都相等">1. 改变数组元素使所有的数组元素都相等</a></li></ul></li><li><a href="#多数投票问题">多数投票问题</a><ul><li><a href="#1-数组中出现次数多于-n--2-的元素">1. 数组中出现次数多于 n / 2 的元素</a></li></ul></li><li><a href="#其它">其它</a><ul><li><a href="#1-平方数">1. 平方数</a></li><li><a href="#2-3-的-n-次方">2. 3 的 n 次方</a></li><li><a href="#3-乘积数组">3. 乘积数组</a></li><li><a href="#4-找出数组中的乘积最大的三个数">4. 找出数组中的乘积最大的三个数</a><!-- GFM-TOC --></li></ul></li></ul><a id="more"></a><h1 id="素数分解"><a href="#素数分解" class="headerlink" title="素数分解"></a>素数分解</h1><p>每一个数都可以分解成素数的乘积，例如 84 = 2<sup>2</sup> * 3<sup>1</sup> * 5<sup>0</sup> * 7<sup>1</sup> * 11<sup>0</sup> * 13<sup>0</sup> * 17<sup>0</sup> * …</p><h1 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h1><p>令 x = 2<sup>m0</sup> * 3<sup>m1</sup> * 5<sup>m2</sup> * 7<sup>m3</sup> * 11<sup>m4</sup> * …</p><p>令 y = 2<sup>n0</sup> * 3<sup>n1</sup> * 5<sup>n2</sup> * 7<sup>n3</sup> * 11<sup>n4</sup> * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><h1 id="最大公约数最小公倍数"><a href="#最大公约数最小公倍数" class="headerlink" title="最大公约数最小公倍数"></a>最大公约数最小公倍数</h1><p>x 和 y 的最大公约数为：gcd(x,y) =  2<sup>min(m0,n0)</sup> * 3<sup>min(m1,n1)</sup> * 5<sup>min(m2,n2)</sup> * …</p><p>x 和 y 的最小公倍数为：lcm(x,y) =  2<sup>max(m0,n0)</sup> * 3<sup>max(m1,n1)</sup> * 5<sup>max(m2,n2)</sup> * …</p><h2 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h2><p>204. Count Primes (Easy)</p><p><a href="https://leetcode.com/problems/count-primes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/count-primes/description/" target="_blank" rel="noopener">力扣</a></p><p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] notPrimes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (notPrimes[i]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 从 i * i 开始，因为如果 k &lt; i，那么 k * i 在之前就已经被去除过了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> j = (<span class="keyword">long</span>) (i) * i; j &lt; n; j += i) &#123;</span><br><span class="line">            notPrimes[(<span class="keyword">int</span>) j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最小公倍数为两数的乘积除以最大公约数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用位操作和减法求解最大公约数"><a href="#3-使用位操作和减法求解最大公约数" class="headerlink" title="3. 使用位操作和减法求解最大公约数"></a>3. 使用位操作和减法求解最大公约数</h2><p><a href="#">编程之美：2.7</a></p><p>对于 a 和 b 的最大公约数 f(a, b)，有：</p><ul><li>如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</li><li>如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b);</li><li>如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2);</li><li>如果 a 和 b 均为奇数，f(a, b) = f(b, a-b);</li></ul><p>乘 2 和除 2 都可以转换为移位操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> isAEven = isEven(a), isBEven = isEven(b);</span><br><span class="line">    <span class="keyword">if</span> (isAEven &amp;&amp; isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * gcd(a &gt;&gt; <span class="number">1</span>, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAEven &amp;&amp; !isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(a &gt;&gt; <span class="number">1</span>, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAEven &amp;&amp; isBEven) &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(a, b &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a - b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><h2 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h2><p>504. Base 7 (Easy)</p><p><a href="https://leetcode.com/problems/base-7/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/base-7/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">boolean</span> isNegative = num &lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (isNegative) &#123;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(num % <span class="number">7</span>);</span><br><span class="line">        num /= <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String ret = sb.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> isNegative ? <span class="string">"-"</span> + ret : ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(num, <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h2><p>405. Convert a Number to Hexadecimal (Easy)</p><p><a href="https://leetcode.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">26</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"1a"</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">"ffffffff"</span><br></pre></td></tr></table></figure><p>负数要用它的补码形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(map[num &amp; <span class="number">0b1111</span>]);</span><br><span class="line">        num &gt;&gt;&gt;= <span class="number">4</span>; <span class="comment">// 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h2><p>168. Excel Sheet Column Title (Easy)</p><p><a href="https://leetcode.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; A</span><br><span class="line">2 -&gt; B</span><br><span class="line">3 -&gt; C</span><br><span class="line">...</span><br><span class="line">26 -&gt; Z</span><br><span class="line">27 -&gt; AA</span><br><span class="line">28 -&gt; AB</span><br></pre></td></tr></table></figure><p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n--;</span><br><span class="line">    <span class="keyword">return</span> convertToTitle(n / <span class="number">26</span>) + (<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">'A'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h1><h2 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h2><p>172. Factorial Trailing Zeroes (Easy)</p><p><a href="https://leetcode.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/description/" target="_blank" rel="noopener">力扣</a></p><p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p><p>对于一个数 N，它所包含 5 的个数为：N/5 + N/5<sup>2</sup> + N/5<sup>3</sup> + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/5<sup>2</sup> 表示不大于 N 的数中 5<sup>2</sup> 的倍数再贡献一个 5 …。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : n / <span class="number">5</span> + trailingZeroes(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="#">编程之美：2.2</a> 。和求解有多少个 5 一样，2 的个数为 N/2 + N/2<sup>2</sup> + N/2<sup>3</sup> + …</p><h1 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h1><h2 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h2><p>67. Add Binary (Easy)</p><p><a href="https://leetcode.com/problems/add-binary/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/add-binary/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = "11"</span><br><span class="line">b = "1"</span><br><span class="line">Return "100".</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            carry++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">'1'</span>) &#123;</span><br><span class="line">            carry++;</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(carry % <span class="number">2</span>);</span><br><span class="line">        carry /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h2><p>415. Add Strings (Easy)</p><p><a href="https://leetcode.com/problems/add-strings/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/add-strings/description/" target="_blank" rel="noopener">力扣</a></p><p>字符串的值为非负整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>, i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i--) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> y = j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">        str.append((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">        carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h1><h2 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h2><p>462. Minimum Moves to Equal Array Elements II (Medium)</p><p><a href="https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Only two moves are needed (remember each move increments or decrements one element):</span><br><span class="line"></span><br><span class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</span><br></pre></td></tr></table></figure><p>每次可以对一个数组元素加一或者减一，求最小的改变次数。</p><p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。理由如下：</p><p>设 m 为中位数。a 和 b 是 m 两边的两个元素，且 b &gt; a。要使 a 和 b 相等，它们总共移动的次数为 b - a，这个值等于 (b - m) + (m - a)，也就是把这两个数移动到中位数的移动次数。</p><p>设数组长度为 N，则可以找到 N/2 对 a 和 b 的组合，使它们都移动到 m 的位置。</p><p><strong>解法 1</strong>  </p><p>先排序，时间复杂度：O(NlogN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        move += nums[h] - nums[l];</span><br><span class="line">        l++;</span><br><span class="line">        h--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> move;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解法 2</strong>  </p><p>使用快速选择找到中位数，时间复杂度 O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> move = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> median = findKthSmallest(nums, nums.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        move += Math.abs(num - median);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> move;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findKthSmallest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, l, h);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            l = j + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[++i] &lt; nums[l] &amp;&amp; i &lt; h) ;</span><br><span class="line">        <span class="keyword">while</span> (nums[--j] &gt; nums[l] &amp;&amp; j &gt; l) ;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h1><h2 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h2><p>169. Majority Element (Easy)</p><p><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">力扣</a></p><p>先对数组排序，最中间那个数出现次数一定多于 n / 2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。可以这么理解该算法：使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素不相等时，令 cnt–。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2，因为如果多于 i / 2 的话 cnt 就一定不会为 0。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, majority = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        majority = (cnt == <span class="number">0</span>) ? num : majority;</span><br><span class="line">        cnt = (majority == num) ? cnt + <span class="number">1</span> : cnt - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h2><p>367. Valid Perfect Square (Easy)</p><p><a href="https://leetcode.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Returns: True</span><br></pre></td></tr></table></figure><p>平方序列：1,4,9,16,..</p><p>间隔：3,5,7,…</p><p>间隔为等差数列，使用这个特性可以得到从 1 开始的平方序列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> subNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        num -= subNum;</span><br><span class="line">        subNum += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h2><p>326. Power of Three (Easy)</p><p><a href="https://leetcode.com/problems/power-of-three/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/power-of-three/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h2><p>238. Product of Array Except Self (Medium)</p><p><a href="https://leetcode.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/product-of-array-except-self/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For example, given [1,2,3,4], return [24,12,8,6].</span><br></pre></td></tr></table></figure><p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p><p>要求时间复杂度为 O(N)，并且不能使用除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] products = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    Arrays.fill(products, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        left *= nums[i - <span class="number">1</span>];</span><br><span class="line">        products[i] *= left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        right *= nums[i + <span class="number">1</span>];</span><br><span class="line">        products[i] *= right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> products;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h2><p>628. Maximum Product of Three Numbers (Easy)</p><p><a href="https://leetcode.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">Leetcode</a> / <a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/description/" target="_blank" rel="noopener">力扣</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: 24</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE, min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; max1) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = max1;</span><br><span class="line">            max1 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; max2) &#123;</span><br><span class="line">            max3 = max2;</span><br><span class="line">            max2 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; max3) &#123;</span><br><span class="line">            max3 = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; min1) &#123;</span><br><span class="line">            min2 = min1;</span><br><span class="line">            min1 = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; min2) &#123;</span><br><span class="line">            min2 = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(max1*max2*max3, max1*min1*min2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!-- GFM-TOC --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#素数分解&quot;&gt;素数分解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#整除&quot;&gt;整除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#最大公约数最小公倍数&quot;&gt;最大公约数最小公倍数&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-生成素数序列&quot;&gt;1. 生成素数序列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-最大公约数&quot;&gt;2. 最大公约数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-使用位操作和减法求解最大公约数&quot;&gt;3. 使用位操作和减法求解最大公约数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#进制转换&quot;&gt;进制转换&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-7-进制&quot;&gt;1. 7 进制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-16-进制&quot;&gt;2. 16 进制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-26-进制&quot;&gt;3. 26 进制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#阶乘&quot;&gt;阶乘&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-统计阶乘尾部有多少个-0&quot;&gt;1. 统计阶乘尾部有多少个 0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#字符串加法减法&quot;&gt;字符串加法减法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-二进制加法&quot;&gt;1. 二进制加法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-字符串加法&quot;&gt;2. 字符串加法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#相遇问题&quot;&gt;相遇问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-改变数组元素使所有的数组元素都相等&quot;&gt;1. 改变数组元素使所有的数组元素都相等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#多数投票问题&quot;&gt;多数投票问题&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-数组中出现次数多于-n--2-的元素&quot;&gt;1. 数组中出现次数多于 n / 2 的元素&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#其它&quot;&gt;其它&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-平方数&quot;&gt;1. 平方数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-3-的-n-次方&quot;&gt;2. 3 的 n 次方&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#3-乘积数组&quot;&gt;3. 乘积数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#4-找出数组中的乘积最大的三个数&quot;&gt;4. 找出数组中的乘积最大的三个数&lt;/a&gt;&lt;!-- GFM-TOC --&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="leetcode题解" scheme="https://LiuHuAshen.github.io/tags/leetcode题解/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统ELK搭建日志采集系统</title>
    <link href="https://liuhuashen.github.io/2020/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FELK%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liuhuashen.github.io/2020/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FELK%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-28T08:55:53.000Z</published>
    <updated>2020-09-28T08:59:03.401Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介：介绍搜索的基本概念，市面上主流的搜索框架elasticSearch和solr等对比</strong></p><ul><li>什么是搜索：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在海量信息中获取我们想要的信息</span><br></pre></td></tr></table></figure><ul><li>传统做法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文档中使用系统的Find查找</span><br><span class="line">mysql中使用like模糊查询</span><br></pre></td></tr></table></figure><ul><li>问题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">海量数据中不能及时响应,少量数据可以通过传统的MySql建立索引解决</span><br><span class="line"></span><br><span class="line">一些无用词不能进行过滤，没法分词</span><br><span class="line"></span><br><span class="line">数据量大的话难以拓展</span><br><span class="line"></span><br><span class="line">相同的数据难以进行相似度最高的进行排序</span><br></pre></td></tr></table></figure><ul><li>搜索引擎:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">存储非结构化的数据</span><br><span class="line"></span><br><span class="line">快速检索和响应我们需要的信息，快-准</span><br><span class="line"></span><br><span class="line">进行相关性的排序，过滤等</span><br><span class="line"></span><br><span class="line">可以去掉停用词(没有特殊含义的词，比如英文的a,is等，中文： 这，的，是等)，框架一般支持可以自定义停用词</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>常用框架：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lucene</span><br><span class="line">    Apache下面的一个开源项目，高性能的、可扩展的工具库，提供搜索的基本架构；</span><br><span class="line">    如果开发人员需用使用的话，需用自己进行开发,成本比较大，但是性能高</span><br><span class="line"></span><br><span class="line">solr</span><br><span class="line">    Solr基于Lucene的全文搜索框架，提供了比Lucene更为丰富的功能，</span><br><span class="line">    同时实现了可配置、可扩展并对查询性能进行了优化</span><br><span class="line">    建立索引时，搜索效率下降，实时索引搜索效率不高</span><br><span class="line">    数据量的增加，Solr的搜索效率会变得更低,适合的搜索应用，对应java客户端的是solrj</span><br></pre></td></tr></table></figure><ul><li>elasticSearch</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基于Lucene的搜索框架, 它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口</span><br><span class="line">上手容易，拓展节点方便，可用于存储和检索海量数据，接近实时搜索，海量数据量增加，搜索响应性能几乎不受影响；</span><br><span class="line">分布式搜索框架，自动发现节点，副本机制，保障可用性</span><br></pre></td></tr></table></figure><h3 id="3、新版本-elasticSearch-6-1-2介绍"><a href="#3、新版本-elasticSearch-6-1-2介绍" class="headerlink" title="3、新版本 elasticSearch 6.1.2介绍"></a>3、新版本 elasticSearch 6.1.2介绍</h3><p><strong>简介：介绍ES的主要特点和使用场景，新特性讲解</strong></p><ul><li>elasticSearch主要特点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：全文检索，结构化检索，数据统计、分析，接近实时处理，分布式搜索(可部署数百台服务器)，处理PB级别的数据搜索纠错，自动完成</span><br><span class="line">使用场景：日志搜索，数据聚合，数据监控，报表统计分析</span><br><span class="line"></span><br><span class="line">国内外使用者：维基百科，Stack Overflow，GitHub</span><br></pre></td></tr></table></figure><ul><li>新特性讲解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">6.1.x版本基于Lucene 7.1.0，更快，性能进一步提升,对应的序列化组件，升级到Jackson 2.8</span><br><span class="line"></span><br><span class="line">自适应副本选择</span><br><span class="line">今天在Elasticsearch中，对同一分片的一系列搜索请求将以循环方式转发到主要和每个副本。如果一个节点启动了长时间的垃圾收集，这可能会出现问题 - 搜索请求仍将被转发到缓慢的节点，并且会影响搜索延迟。</span><br><span class="line"></span><br><span class="line">在6.1中，我们添加了一个称为自适应副本选择的实验性功能。每个节点跟踪并比较搜索请求到其他节点的时间，并使用这些信息来调整向特定节点发送请求的频率。在我们的基准测试中，这样可以大大提高搜索吞吐量，降低99％的延迟。</span><br><span class="line"></span><br><span class="line">这个选项在默认情况下是禁用的</span><br><span class="line"></span><br><span class="line">推荐使用5.0版本推出的Java REST/HTTP客户端，依赖少，比Transport使用更方便，在基准测试中，性能并不输于Transport客户端，</span><br><span class="line"></span><br><span class="line">在5.0到6.0版本中，每次有对应的API更新, 文档中也说明，推荐使用这种方式进行开发使用,所有可用节点间的负载均衡</span><br><span class="line"></span><br><span class="line">在节点故障和特定响应代码的情况下进行故障转移,失败的连接处罚（失败的节点是否重试取决于失败的连续次数;失败的失败次数越多，客户端在再次尝试同一节点之前等待的时间越长）</span><br></pre></td></tr></table></figure><ul><li>官方文档：</li></ul><p>(1) 6.0更新特性 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/release-notes-6.0.0.html#breaking-java-6.0.0" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.0/release-notes-6.0.0.html#breaking-java-6.0.0</a> (2) 6.1更新特性 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.1/release-notes-6.1.0.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.1/release-notes-6.1.0.html</a></p><h3 id="4、windows安装启动ElasticSearch"><a href="#4、windows安装启动ElasticSearch" class="headerlink" title="4、windows安装启动ElasticSearch"></a>4、windows安装启动ElasticSearch</h3><p><strong>简介：windows环境下安装JDK8和 ElasticSearch</strong></p><h3 id="5、阿里云服务器-快速安装ElasticSearch"><a href="#5、阿里云服务器-快速安装ElasticSearch" class="headerlink" title="5、阿里云服务器 快速安装ElasticSearch"></a>5、阿里云服务器 快速安装ElasticSearch</h3><p><strong>简介：阿里云ecs介绍,wget命令下载安装包,快速部署 elasticSearch节点</strong></p><ul><li>linux下使用wget下载jdk8:</li></ul><ol><li>进到目录/usr/local/software</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz&quot;</span><br></pre></td></tr></table></figure><ol><li>vim /etc/profile</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加入</span><br><span class="line">export JAVA_HOME=/usr/local/software/jdk8</span><br><span class="line">export JAVA_BIN=/usr/local/software/jdk8</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export JAVA_HOME JAVA_BIN PATH CLASSPATH</span><br></pre></td></tr></table></figure><ul><li>使用wget 下载elasticsearch安装包</li></ul><p>wget <a href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz" target="_blank" rel="noopener">https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.2.2.tar.gz</a></p><ul><li>解压</li></ul><p>tar -zxvf elasticsearch-6.2.2.tar.gz</p><ul><li>配置es出现相关问题处理：</li></ul><p>1、问题一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000c5330000, 986513408, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12)</span><br><span class="line">#</span><br><span class="line"># There is insufficient memory for the Java Runtime Environment to continue.</span><br><span class="line"></span><br><span class="line"># Native memory allocation (mmap) failed to map 986513408 bytes for committing reserved memory.</span><br><span class="line"></span><br><span class="line"># An error report file with more information is saved as:</span><br><span class="line"></span><br><span class="line"># /usr/local/software/temp/elasticsearch-6.2.2/hs_err_pid1912.log</span><br></pre></td></tr></table></figure><ul><li><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存不够，购买阿里云的机器可以动态增加内存</span><br></pre></td></tr></table></figure></li></ul><p>2、问题二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz95j86y235aroi85ht0Z bin]# ./elasticsearch</span><br><span class="line">[2018-02-22T20:14:04,870][WARN ][o.e.b.ElasticsearchUncaughtExceptionHandler][] uncaught exception in thread [main]</span><br><span class="line">org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.init(Elasticsearch.java:125) ~[elasticsearch-6.2.2.jar:6.2.2]</span><br><span class="line">at org.elasticsearch.bootstrap.Elasticsearch.execute(Elasticsearch.java:112) ~[elasticsearch-6.2.2.jar:6.2.2]</span><br><span class="line">at org.elasticsearch.cli.EnvironmentAwareCommand.execute(EnvironmentAwareCommand.java:86) ~[elasticsearch-6.2.2.jar:6.2.2]</span><br><span class="line">at org.elasticsearch.cli.Command.mainWithoutErrorHandling(Command.java:124) ~[elasticsearch-cli-6.2.2.jar:6.2.2]</span><br></pre></td></tr></table></figure><ul><li><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用非root用户</span><br><span class="line">添加用户：useradd -m 用户名  然后设置密码  passwd 用户名</span><br></pre></td></tr></table></figure></li></ul><p>3、问题三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./elasticsearch</span><br><span class="line">Exception in thread &quot;main&quot; java.nio.file.AccessDeniedException: /usr/local/software/temp/elasticsearch-6.2.2/config/jvm.options</span><br></pre></td></tr></table></figure><ul><li><p>解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权限不够 chmod 777 -R 当前es目录</span><br></pre></td></tr></table></figure></li></ul><ul><li>常见配置问题资料：<a href="https://www.jianshu.com/p/c5d6ec0f35e0" target="_blank" rel="noopener">https://www.jianshu.com/p/c5d6ec0f35e0</a></li></ul><h3 id="6、ElasticSearch目录和配置文件介绍"><a href="#6、ElasticSearch目录和配置文件介绍" class="headerlink" title="6、ElasticSearch目录和配置文件介绍"></a>6、ElasticSearch目录和配置文件介绍</h3><p><strong>简介：介绍ES目录结构，配置文件基本说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin: 启动文件</span><br><span class="line">log: 日志文件，包括运行日志，慢查询日志</span><br><span class="line">config: 核心配置文件</span><br><span class="line">lib: 依赖包</span><br><span class="line">plugins :插件</span><br></pre></td></tr></table></figure><h3 id="7、ElasticSearch核心配置文件讲解，性能优化配置"><a href="#7、ElasticSearch核心配置文件讲解，性能优化配置" class="headerlink" title="7、ElasticSearch核心配置文件讲解，性能优化配置"></a>7、ElasticSearch核心配置文件讲解，性能优化配置</h3><p><strong>简介：讲解核心配置文件，JVM参数配置，性能优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">健康状态检查：http://localhost:9200/_cluster/health</span><br><span class="line">  jvm.options         虚拟机参数配置文件</span><br><span class="line"> 配置heap内存一样</span><br><span class="line"> elasticsearch.yml   主配置文件</span><br><span class="line">  cluster.name  集群名称，同一个网段自动加入</span><br><span class="line">  node.name  节点名称</span><br><span class="line">  http.port     http端口</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地启动多个节点，复制es安装包的时候，需要删除里面data目录里面的资料，不然无法加入集群</span><br></pre></td></tr></table></figure><h3 id="8、ElasticSearch基础概念讲解"><a href="#8、ElasticSearch基础概念讲解" class="headerlink" title="8、ElasticSearch基础概念讲解"></a>8、ElasticSearch基础概念讲解</h3><p><strong>简介:es的index索引,document文档对象，副本，多节点集群等基础知识</strong></p><ul><li><p>通俗的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中, 索引名称必须是小写</span><br><span class="line">Relational DB -&gt; Database -&gt; Table -&gt; Row -&gt; Column</span><br><span class="line">Elasticsearch -&gt; Indice   -&gt; Type  -&gt; Document -&gt; Field</span><br></pre></td></tr></table></figure></li><li><p>分片shards：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据量特大，没有足够大的硬盘空间来一次性存储，且一次性搜索那么多的数据，响应跟不上es提供把数据进行分片存储，这样方便进行拓展和提高吞吐</span><br></pre></td></tr></table></figure></li><li><p>副本replicas：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分片的拷贝，当主分片不可用的时候，副本就充当主分片进行使用</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch中的每个索引分配5个主分片和1个副本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样每个索引总共就有10个分片。</span><br></pre></td></tr></table></figure></li></ul><h3 id="9、search搜索语句入门之URL搜索"><a href="#9、search搜索语句入门之URL搜索" class="headerlink" title="9、search搜索语句入门之URL搜索"></a>9、search搜索语句入门之URL搜索</h3><p><strong>简介:讲解URL中的_search搜索语句的基本使用，美化响应结果, 索引的基础操作</strong></p><ul><li><p>集群健康检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/_cat/health?v</span><br><span class="line">http://localhost:9200/_cluster/health（推荐）</span><br></pre></td></tr></table></figure></li><li><p>状态说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">green：正常</span><br><span class="line">yellow: 集群正常 数据正常，部分副本不正常</span><br><span class="line">red: 集群部分正常，数据可能丢失，需要紧急修复</span><br></pre></td></tr></table></figure></li><li><p>查询节点列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/_cat/nodes?v</span><br></pre></td></tr></table></figure></li><li><p>查看所有索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:9200/_cat/indices?v</span><br><span class="line">目前 集群中没有任何索引</span><br></pre></td></tr></table></figure></li><li><p>补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl </span><br><span class="line">   -X 指定http的请求方法 有HEAD GET POST PUT DELETE </span><br><span class="line">   -d 指定要传输的数据 </span><br><span class="line">   -H 指定http请求头信息</span><br></pre></td></tr></table></figure></li><li><p>新增索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;localhost:9201/blog_test?pretty&apos;</span><br><span class="line">curl -XPUT &apos;localhost:9201/blog?pretty&apos;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE &apos;localhost:9200/blog_test?pretty&apos;</span><br><span class="line"></span><br><span class="line">新增一条记录，并指定为article类型，ID为1</span><br><span class="line"></span><br><span class="line">curl -XPUT -H &quot;Content-Type: application/json&quot; &apos;localhost:9201/blog/article/1?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;D课堂啦啦啦&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;xdclass.net  D课堂成立于2016年的，专注互联网在线教育，课程范围包括前端，后端，大数据，人工智能，微信开发等&quot;</span><br><span class="line">&#125;&apos;</span><br><span class="line"></span><br><span class="line">curl -XPUT -H &quot;Content-Type: application/json&quot; &apos;localhost:9201/blog/article/2?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;testsfsdfdsfdsf&quot;,</span><br><span class="line">  &quot;PV&quot;:10</span><br><span class="line">&#125;&apos;</span><br><span class="line"></span><br><span class="line">curl -XPUT -H &quot;Content-Type: application/json&quot; &apos;localhost:9201/blog/article/3?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;test&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;testsfsdfdsfdsf&quot;,</span><br><span class="line">  &quot;PV&quot;:23</span><br><span class="line">&#125;&apos;</span><br><span class="line">空间不够新增失败处理 curl -XPUT -H &quot;Content-Type: application/json&quot; http://localhost:9200/_all/_settings -d &apos;&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;&apos;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &#123;</span><br><span class="line">    &quot;root_cause&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot; : &quot;cluster_block_exception&quot;,</span><br><span class="line">        &quot;reason&quot; : &quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot; : &quot;cluster_block_exception&quot;,</span><br><span class="line">    &quot;reason&quot; : &quot;blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot; : 403</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ID查询记录</span><br><span class="line">curl -XGET &apos;localhost:9200/blog/article/1&apos;</span><br><span class="line">curl -XGET &apos;localhost:9200/blog/article/1?pretty&apos;(美化推荐)</span><br><span class="line"></span><br><span class="line">搜索</span><br><span class="line">curl -XGET &apos;http://localhost:9201/blog/article/_search?q=title:A&apos;</span><br></pre></td></tr></table></figure></li></ul><h3 id="10、search搜索语句入门之结构化查询语句DSL"><a href="#10、search搜索语句入门之结构化查询语句DSL" class="headerlink" title="10、search搜索语句入门之结构化查询语句DSL"></a>10、search搜索语句入门之结构化查询语句DSL</h3><p><strong>简介：讲解结构化查询语句DSL的使用，bool，filter查询等</strong></p><ul><li>新增数据集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT -H &quot;Content-Type: application/json&quot; &apos;localhost:9201/blog/article/7?pretty&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;elk搭建日志采集系统&quot;,</span><br><span class="line">  &quot;content&quot;:&quot;elk elasticsearch logstash kibana&quot;,</span><br><span class="line">  &quot;PV&quot;:18</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><ul><li>什么是query DSL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Domain Specific Language 领域特定语言</span><br><span class="line">Elasticsearch提供了完整的查询DSL，基于JSON定义查询</span><br><span class="line">用于构造复杂的查询语句</span><br><span class="line">curl查询(空格处理不当,会出问题)</span><br><span class="line"></span><br><span class="line">curl -XPOST -H &quot;Content-Type: application/json&quot; &apos;http://localhost:9201/blog/article/_search&apos; -d &apos;&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;title&quot; : &quot;elk&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br><span class="line">建议使用postman工具</span><br><span class="line">post方式提交，增加http头信息</span><br><span class="line">body里面选row格式，粘贴对应的dsl即可</span><br><span class="line">bool查询入门   </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;elk&quot; &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;小D&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter查询入门（filtered语法已经在5.0版本后移除了，在2.0时候标记过期，改用filter ）</span><br><span class="line">参考地址：https://www.elastic.co/guide/en/elasticsearch/reference/5.0/query-dsl-filtered-query.html</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;PV&quot;: &#123;</span><br><span class="line">            &quot;gt&quot;: 15</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &quot;ELK&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总结：（官网参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html）" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html）</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">大部分filter的速度快于query的速度 </span><br><span class="line">filter不会计算相关度得分，且结果会有缓存，效率高</span><br><span class="line">全文搜索、评分排序，使用query</span><br><span class="line">是非过滤，精确匹配，使用filter</span><br></pre></td></tr></table></figure><h2 id="章节三-Logstash零基础入门到采集日志实战"><a href="#章节三-Logstash零基础入门到采集日志实战" class="headerlink" title="章节三 Logstash零基础入门到采集日志实战"></a>章节三 Logstash零基础入门到采集日志实战</h2><h3 id="11、Logstash基本介绍和使用场景"><a href="#11、Logstash基本介绍和使用场景" class="headerlink" title="11、Logstash基本介绍和使用场景"></a>11、Logstash基本介绍和使用场景</h3><p><strong>简介：讲解什么是logstash，里面的基本工作流程input,filter,output等说明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">什么是logstash (文档地址 https://www.elastic.co/guide/en/logstash/current/index.html)</span><br><span class="line">开源的日志收集引擎，具备实时传输的能力</span><br><span class="line">读取不同的数据源，并进行过滤，开发者自定义规范输出到目的地</span><br><span class="line">日志来源多（如系统日志，应用日志，服务器日志等）</span><br></pre></td></tr></table></figure><ul><li>流程讲解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logstash通过管道pipeline进行传输，必选的两个组件是输入input和输出output，还有个可选过滤器filter</span><br><span class="line">logstash将数据流中等每一条数据称之为一个event,即读取每一行数据的行为叫做事件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 输入</span><br><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 过滤器</span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 输出</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、Logstash插件介绍"><a href="#12、Logstash插件介绍" class="headerlink" title="12、Logstash插件介绍"></a>12、Logstash插件介绍</h3><p><strong>简介：讲解input,filter和output的插件的基本使用</strong></p><ul><li>简单的配置 test.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">input &#123;  </span><br><span class="line"></span><br><span class="line"># 从文件读取日志信息</span><br><span class="line"></span><br><span class="line">  file &#123;  </span><br><span class="line">     path =&gt; &quot;/var/log/messages&quot;</span><br><span class="line">     type =&gt; &quot;system&quot;</span><br><span class="line">     start_position =&gt; &quot;beginning&quot;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">filter &#123;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">output &#123;  </span><br><span class="line">#标准输出</span><br><span class="line">     elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [&quot;localhost:9200&quot;]      </span><br><span class="line">        index =&gt; &quot;logstash-test-%&#123;type&#125;-%&#123;host&#125;&quot;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>input插件：<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/input-plugins.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file，http，kafka，rabbitmq等</span><br></pre></td></tr></table></figure><ul><li>filter插件：<a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/filter-plugins.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grok(号称将非标准化的日志数据转换成标准化并且可搜索数据最好的方式，常用于处理Niginx，sysLog等日志)</span><br><span class="line">drop(跳过某些日志，不进入output)</span><br><span class="line">geoip(获取地理信息)</span><br></pre></td></tr></table></figure><ul><li>output插件：<a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/output-plugins.html</a></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elasticSearch,cvs,email,file等</span><br></pre></td></tr></table></figure><h3 id="13、阿里云服务器部署Logstash-6-1-2"><a href="#13、阿里云服务器部署Logstash-6-1-2" class="headerlink" title="13、阿里云服务器部署Logstash 6.1.2"></a>13、阿里云服务器部署Logstash 6.1.2</h3><p><strong>简介：阿里云Centos部署Logstash，目录文件，配置讲解，基本功能测试</strong></p><ul><li>下载安装包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/logstash/logstash-6.2.2.tar.gz</span><br><span class="line">解压：tar -zxvf logstash-6.2.2.tar.gz</span><br></pre></td></tr></table></figure><ul><li>快速启动(需要java8 jre,目前不支持java9)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/logstash -e &apos;input &#123;stdin &#123;&#125;&#125; output &#123;stdout &#123;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure><ul><li>目录文件说明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/guide/en/logstash/6.2/dir-layout.html</span><br></pre></td></tr></table></figure><ul><li>配置讲解</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/guide/en/logstash/6.2/logstash-settings-file.html</span><br><span class="line"></span><br><span class="line">logstash.yml  修改 pipeline.workers，根据CPU核数增加1到2即可</span><br><span class="line">jvm.options  修改 xms和xmx为相同，一般是系统内存三份之二</span><br></pre></td></tr></table></figure><h3 id="14、Logstash采集输送日志input-filter-output流程测试"><a href="#14、Logstash采集输送日志input-filter-output流程测试" class="headerlink" title="14、Logstash采集输送日志input filter output流程测试"></a>14、Logstash采集输送日志input filter output流程测试</h3><p><strong>简介：讲解Logstash采集日志和输送日志流程测试,包括input，filter和output元素的测试</strong></p><ul><li>bin/logstash -f test1.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./logstash -f ../config/test1.conf</span><br></pre></td></tr></table></figure><ul><li>codec的使用( Coder/decoder 两个单词首字母缩写）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Codec: 解码编码 数据格式  </span><br><span class="line">好处 更方便logstash与支持自定义数据格式的运维产品进行使用</span><br></pre></td></tr></table></figure><ul><li>logstash更细化的处理流程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">input-&gt;decode-&gt;filter-&gt;encode-&gt;output  </span><br><span class="line">配置一 test1.conf</span><br><span class="line">========================================</span><br><span class="line">input &#123;</span><br><span class="line"></span><br><span class="line"># 从文件读取日志信息 输送到控制台</span><br><span class="line"></span><br><span class="line">    file &#123;</span><br><span class="line">        path =&gt; &quot;/Users/jack/Desktop/person/elk/elasticsearch-6.1.1/logs/elasticsearch.log&quot;</span><br><span class="line"></span><br><span class="line"># codec =&gt; &quot;json&quot; ## 以JSON格式读取日志</span><br><span class="line"></span><br><span class="line">        type =&gt; &quot;elasticsearch&quot;</span><br><span class="line">        start_position =&gt; &quot;beginning&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># filter &#123;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># &#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line"># 标准输出</span><br><span class="line"></span><br><span class="line"># stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 输出进行格式化，采用Ruby库来解析日志</span><br><span class="line"></span><br><span class="line">     stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter使用</span><br><span class="line">例子</span><br><span class="line">切割插件mutate，随意输入一串以|分割的字符，比如 &quot;123|000|ttter|sdfds*=123|dfwe</span><br><span class="line">配置二 test2_filter.conf</span><br><span class="line">========================================</span><br><span class="line">input &#123;</span><br><span class="line">   stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;  </span><br><span class="line">    mutate &#123;  </span><br><span class="line">        split =&gt; [&quot;message&quot;, &quot;|&quot;]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line"></span><br><span class="line"># 标准输出</span><br><span class="line"></span><br><span class="line"># stdout &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 输出进行格式化，采用Ruby库来解析日志</span><br><span class="line"></span><br><span class="line">     stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15、logstash案例实战之读取日志输出到elasticsearch"><a href="#15、logstash案例实战之读取日志输出到elasticsearch" class="headerlink" title="15、logstash案例实战之读取日志输出到elasticsearch"></a>15、logstash案例实战之读取日志输出到elasticsearch</h3><p><strong>简介：从日志文件中读取日志，输出到elasticsearch集群中</strong></p><ul><li>logstash配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">配置三 test3_es.conf</span><br><span class="line">========================================</span><br><span class="line">input &#123;</span><br><span class="line">        file &#123;</span><br><span class="line">                path =&gt; &quot;/Users/jack/Desktop/person/elk/elasticsearch-6.1.1/logs/elasticsearch.log&quot;</span><br><span class="line">                type =&gt; &quot;elasticsearch&quot;</span><br><span class="line">                start_position =&gt; &quot;beginning&quot; #从文件开始处读写</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output&#123;</span><br><span class="line">    elasticsearch&#123;</span><br><span class="line">        hosts=&gt;[&quot;127.0.0.1:9201&quot;]  </span><br><span class="line">        index =&gt; &quot;es-message-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class="line">     &#125;</span><br><span class="line">   stdout&#123;codec =&gt; rubydebug&#125;</span><br><span class="line">&#125;</span><br><span class="line">========================================</span><br></pre></td></tr></table></figure><ul><li>验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看索引列表 http://localhost:9201/_cat/indices?v</span><br><span class="line">查看数据 http://localhost:9201/es-message-2018.02.26/_search</span><br></pre></td></tr></table></figure><h2 id="章节四-Kibana-6-2版本基础入门到实战"><a href="#章节四-Kibana-6-2版本基础入门到实战" class="headerlink" title="章节四 Kibana 6.2版本基础入门到实战"></a>章节四 Kibana 6.2版本基础入门到实战</h2><h3 id="16、阿里云cenos服务器部署kibana6-2-2"><a href="#16、阿里云cenos服务器部署kibana6-2-2" class="headerlink" title="16、阿里云cenos服务器部署kibana6.2.2"></a>16、阿里云cenos服务器部署kibana6.2.2</h3><p><strong>简介：快速部署kibana，并配置外网可以访问</strong></p><ul><li>阿里云下载安装kibana</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/kibana/kibana-6.2.2-linux-x86_64.tar.gz</span><br><span class="line">解压 tar -zxvf kibana-6.2.2-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><ul><li>访问地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本机：localhost:5601</span><br><span class="line">阿里云机器：http://120.79.160.143:5601</span><br></pre></td></tr></table></figure><ul><li>阿里云外网访问</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开放端口,修改配置文件 confing目录下的kibana.yml</span><br><span class="line">server.host: &quot;0.0.0.0&quot;</span><br></pre></td></tr></table></figure><ul><li>守护进程后台启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup  XXX  &amp;</span><br></pre></td></tr></table></figure><h3 id="17、kibana基本介绍、和elasticSearch版本兼容问题"><a href="#17、kibana基本介绍、和elasticSearch版本兼容问题" class="headerlink" title="17、kibana基本介绍、和elasticSearch版本兼容问题"></a>17、kibana基本介绍、和elasticSearch版本兼容问题</h3><p><strong>简介：讲解什么是kibana，目录文件讲解，配置等</strong> 官网文档地址：<a href="https://www.elastic.co/guide/en/kibana/current/setup.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/current/setup.html</a> ELK</p><ul><li>注意事项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kibana和elsticserch版本不能差别大，否则无法正常使用 比如 Kibana 6.x 和 Elasticsearch 2.x不能正常使</span><br><span class="line">运行比Kibana更高版本的Elasticsearch通常可以工作 例如Kibana 5.0和Elasticsearch 5.1</span><br><span class="line"></span><br><span class="line">版本差异会有一些警告出现，除非两者升级到相同的版本</span><br><span class="line"></span><br><span class="line">windows下安装启动文档 https://www.elastic.co/guide/en/kibana/current/windows.html</span><br></pre></td></tr></table></figure><ul><li>kibana.yml常见配置项</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch.pingTimeout     日常用的ping</span><br><span class="line">elasticsearch.requestTimeout  读取es的超时时间</span><br><span class="line">elasticsearch.url es主机地址</span><br><span class="line">elasticsearch.username  es鉴权的用户名</span><br><span class="line">elasticsearch.password  es鉴权的密码</span><br></pre></td></tr></table></figure><h3 id="18、kibana面板讲解和功能使用说明"><a href="#18、kibana面板讲解和功能使用说明" class="headerlink" title="18、kibana面板讲解和功能使用说明"></a>18、kibana面板讲解和功能使用说明</h3><p><strong>简介：讲解kibana的web界面，各个模块划分，功能的基本使用</strong></p><ul><li>kibana状态及服务器资源使用率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://120.79.160.143:5601/status</span><br><span class="line"></span><br><span class="line">基础操作文档：https://www.elastic.co/guide/en/kibana/current/getting-started.html</span><br></pre></td></tr></table></figure><ul><li>创建索引表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用*统配符，去匹配ES中的一个或多个索引(如果没有匹配，无法点击下一步)</span><br></pre></td></tr></table></figure><ul><li>discover面板发现数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以指定时间进行查询</span><br><span class="line">可以使显示的字段</span><br><span class="line">查询索引的数据，可以使用lucence语法进行查询</span><br></pre></td></tr></table></figure><h2 id="章节五-项目实战系列之阿里云服务器部署ELK，采集业务日志和分析"><a href="#章节五-项目实战系列之阿里云服务器部署ELK，采集业务日志和分析" class="headerlink" title="章节五 项目实战系列之阿里云服务器部署ELK，采集业务日志和分析"></a>章节五 项目实战系列之阿里云服务器部署ELK，采集业务日志和分析</h2><h3 id="19、项目实战系列之《采集业务应用日志》配置"><a href="#19、项目实战系列之《采集业务应用日志》配置" class="headerlink" title="19、项目实战系列之《采集业务应用日志》配置"></a>19、项目实战系列之《采集业务应用日志》配置</h3><p><strong>简介：选择日志源，配置logstash采集并输送到elasticSeach</strong></p><ul><li>常见问题解决</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JVM内存溢出导致的 ES或者Logstash服务启不来，报错 insufficient memory</span><br><span class="line">解决：升级机器的内存和CPU；</span><br><span class="line">或者改elasticSeach和logstash的JVM.option，最大堆内存xmx和初始堆内存xms</span><br><span class="line"></span><br><span class="line">ES启动报错</span><br><span class="line">seccomp unavailable: CONFIG_SECCOMP not compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed</span><br><span class="line"></span><br><span class="line">修改elasticsearch.yml 添加一下内容</span><br><span class="line">bootstrap.memory_lock: false   为了避免内存和磁盘之间的swap</span><br><span class="line">bootstrap.system_call_filter: false  </span><br><span class="line"></span><br><span class="line">ERROR: bootstrap checks failed</span><br><span class="line">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least </span><br><span class="line"></span><br><span class="line">临时设置：sudo sysctl -w vm.max_map_count=262144</span><br><span class="line">永久修改：</span><br><span class="line">修改/etc/sysctl.conf 文件，添加 “vm.max_map_count”设置</span><br><span class="line">并执行：sysctl -p</span><br></pre></td></tr></table></figure><h3 id="20、项目实战系列一之《采集业务应用日志》应用"><a href="#20、项目实战系列一之《采集业务应用日志》应用" class="headerlink" title="20、项目实战系列一之《采集业务应用日志》应用"></a>20、项目实战系列一之《采集业务应用日志》应用</h3><p><strong>简介：通过kibana的web管理界面，建立简单的日志分析功能</strong></p><h3 id="21、项目实战系列之Kibana图形、报表分析"><a href="#21、项目实战系列之Kibana图形、报表分析" class="headerlink" title="21、项目实战系列之Kibana图形、报表分析"></a>21、项目实战系列之Kibana图形、报表分析</h3><p><strong>简介：讲解业务应用日志在Kibana上的可视化分析，柱状图，饼状图等</strong></p><ul><li>官方文档地址：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/guide/en/kibana/current/tutorial-load-dataset.html</span><br></pre></td></tr></table></figure><ul><li>下载数据集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip</span><br><span class="line">解压 unzip accounts.zip</span><br></pre></td></tr></table></figure><ul><li>导入数据到es中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &apos;Content-Type: application/x-ndjson&apos; -XPOST &apos;localhost:9200/bank/account/_bulk?pretty&apos; --data-binary @accounts.json</span><br></pre></td></tr></table></figure><ul><li>示例地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.elastic.co/guide/en/kibana/current/tutorial-visualizing.html</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;简介：介绍搜索的基本概念，市面上主流的搜索框架elasticSearch和solr等对比&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是搜索：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在海量信息中获取我们想要的信息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;传统做法：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;文档中使用系统的Find查找&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql中使用like模糊查询&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;问题：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;海量数据中不能及时响应,少量数据可以通过传统的MySql建立索引解决&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一些无用词不能进行过滤，没法分词&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数据量大的话难以拓展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;相同的数据难以进行相似度最高的进行排序&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;



&lt;ul&gt;
&lt;li&gt;搜索引擎:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;存储非结构化的数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;快速检索和响应我们需要的信息，快-准&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;进行相关性的排序，过滤等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以去掉停用词(没有特殊含义的词，比如英文的a,is等，中文： 这，的，是等)，框架一般支持可以自定义停用词&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="ELK" scheme="https://LiuHuAshen.github.io/tags/ELK/"/>
    
  </entry>
  
  <entry>
    <title>高并发编程Netty</title>
    <link href="https://liuhuashen.github.io/2020/09/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BNetty/"/>
    <id>https://liuhuashen.github.io/2020/09/17/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8BNetty/</id>
    <published>2020-09-17T08:56:00.000Z</published>
    <updated>2020-09-17T11:44:20.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章：高并发编程Netty"><a href="#第一章：高并发编程Netty" class="headerlink" title="第一章：高并发编程Netty"></a>第一章：高并发编程Netty</h2><h3 id="1、高并发编程Netty框架"><a href="#1、高并发编程Netty框架" class="headerlink" title="1、高并发编程Netty框架"></a>1、高并发编程Netty框架</h3><ul><li><p>学习基础：<br>1、牢固的java基础</p><p>2、熟悉Linux服务器</p><p>3、有基础的网络知识</p></li></ul><h3 id="2、异步事件驱动NIO框架Netty介绍"><a href="#2、异步事件驱动NIO框架Netty介绍" class="headerlink" title="2、异步事件驱动NIO框架Netty介绍"></a>2、异步事件驱动NIO框架Netty介绍</h3><p><strong>简介：介绍Netty来源，版本，目前在哪些主流公司和产品框架使用</strong></p><ul><li><p>Netty是由JBOSS提供的一个java开源框架, 是业界最流行的NIO框架，整合了多种协议（ 包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，精心设计的框架，在多个大型商业项目中得到充分验证。 1）API使用简单 2）成熟、稳定 3）社区活跃 有很多种NIO框架 如mina 4）经过大规模的验证（互联网、大数据、网络游戏、电信通信行业）</p><a id="more"></a></li><li><p>那些主流框架产品在用？</p><ul><li><p>搜索引擎框架 ElasticSerach</p></li><li><p>Hadopp子项目Avro项目，使用Netty作为底层通信框架</p></li><li><p>阿里巴巴开源的RPC框架 Dubbo</p><ul><li><p>地址：<a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Netty在Dubbo里面使用的地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/apache/incubator-dubbo/tree/master/dubbo-remoting/dubbo-remoting-netty4/src/main/java/org/apache/dubbo/remoting/transport/netty4</span><br></pre></td></tr></table></figure><p>补充：netty4是dubbo2.5.6后引入的，2.5.6之前的netty用的是netty3</p></li></ul></li></ul></li></ul><h4 id="3、高并发编程Netty实战课程开发环境准备"><a href="#3、高并发编程Netty实战课程开发环境准备" class="headerlink" title="3、高并发编程Netty实战课程开发环境准备"></a>3、高并发编程Netty实战课程开发环境准备</h4><p><strong>简介：讲解Netty实战开发环境</strong></p><p>开发环境：IDEA旗舰版/Eclipse + JDK8 + Maven3.5以上版本 + Netty4.x</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Netty版本说明</span><br><span class="line">    采用最新的4.x版本，只要大版本一致就可以 3比较老旧，5废弃了</span><br><span class="line"></span><br><span class="line">    官方文档: https://netty.io/wiki/user-guide-for-4.x.html</span><br><span class="line"></span><br><span class="line">    Github地址：https://github.com/netty/netty</span><br></pre></td></tr></table></figure><h2 id="第二章：使用JDK自带BIO编写一个Client-Server通信"><a href="#第二章：使用JDK自带BIO编写一个Client-Server通信" class="headerlink" title="第二章：使用JDK自带BIO编写一个Client-Server通信"></a>第二章：使用JDK自带BIO编写一个Client-Server通信</h2><h3 id="1、BIO网络编程实战之编写BioServer服务端"><a href="#1、BIO网络编程实战之编写BioServer服务端" class="headerlink" title="1、BIO网络编程实战之编写BioServer服务端"></a>1、BIO网络编程实战之编写BioServer服务端</h3><p><strong>简介: 使用jdk自带的Bio编写一个统一时间服务</strong></p><h3 id="2、BIO网络编程实战之编写BioClient客服端"><a href="#2、BIO网络编程实战之编写BioClient客服端" class="headerlink" title="2、BIO网络编程实战之编写BioClient客服端"></a>2、BIO网络编程实战之编写BioClient客服端</h3><p><strong>简介：使用BIO网络编程编写BioClient客户端</strong></p><h3 id="3、BIO编写Client-Server通信优缺点分析"><a href="#3、BIO编写Client-Server通信优缺点分析" class="headerlink" title="3、BIO编写Client/Server通信优缺点分析"></a>3、BIO编写Client/Server通信优缺点分析</h3><p><strong>简介：讲解BIO的优缺点，为啥不能高并发情况下性能弱</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优点：</span><br><span class="line">    模型简单</span><br><span class="line">    编码简单</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">    性能瓶颈，请求数和线程数 N：N关系</span><br><span class="line">    高并发情况下，CPU切换线程上下文损耗大</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例：web服务器Tomcat7之前，都是使用BIO，7之后就使用NIO</span><br><span class="line"></span><br><span class="line">改进：伪NIO,使用线程池去处理业务逻辑</span><br></pre></td></tr></table></figure><hr><h2 id="第三章：-面试核心-服务端网络编程常见网络IO模型讲解"><a href="#第三章：-面试核心-服务端网络编程常见网络IO模型讲解" class="headerlink" title="第三章：(面试核心)服务端网络编程常见网络IO模型讲解"></a>第三章：(面试核心)服务端网络编程常见网络IO模型讲解</h2><h3 id="1、最通俗的方式讲解-什么是阻塞-非阻塞，什么是同-异步"><a href="#1、最通俗的方式讲解-什么是阻塞-非阻塞，什么是同-异步" class="headerlink" title="1、最通俗的方式讲解 什么是阻塞/非阻塞，什么是同/异步"></a>1、最通俗的方式讲解 什么是阻塞/非阻塞，什么是同/异步</h3><p><strong>简介：使用最通俗概念讲解 同步异步、堵塞和非堵塞</strong></p><ul><li>洗衣机洗衣服<ul><li>洗衣机洗衣服（无论阻塞式IO还是非阻塞式IO，都是同步IO模型）</li></ul></li><li>同步阻塞：你把衣服丢到洗衣机洗，然后看着洗衣机洗完，洗好后再去晾衣服（你就干等，啥都不做，阻塞在那边）</li><li>同步非阻塞：你把衣服丢到洗衣机洗，然后会客厅做其他事情，定时去阳台看洗衣机是不是洗完了，洗好后再去晾衣服（等待期间你可以做其他事情，比如用电脑打开小D课堂看视频学习）</li><li>异步阻塞: 你把衣服丢到洗衣机洗，然后看着洗衣机洗完，洗好后再去晾衣服（几乎没这个情况，几乎没这个说法，可以忽略）</li><li>异步非阻塞：你把衣服丢到洗衣机洗，然后会客厅做其他事情，洗衣机洗好后会自动去晾衣服，晾完成后放个音乐告诉你洗好衣服并晾好了</li></ul><h3 id="2、-BAT面试核心知识-Linux网络编程中的五种I-O模型讲解上集"><a href="#2、-BAT面试核心知识-Linux网络编程中的五种I-O模型讲解上集" class="headerlink" title="2、(BAT面试核心知识)Linux网络编程中的五种I/O模型讲解上集"></a>2、(BAT面试核心知识)Linux网络编程中的五种I/O模型讲解上集</h3><p><strong>简介：linux网络编程中的IO模型讲解上集</strong></p><ul><li>网络IO,用户程序和内核的交互为基础进行讲解</li><li>IO操作分两步：发起IO请求等待数据准备，实际IO操作（洗衣服，晾衣服） 同步须要主动读写数据，在读写数据的过程中还是会阻塞（好比晾衣服阻塞了你） 异步仅仅须要I/O操作完毕的通知。并不主动读写数据，由操作系统内核完毕数据的读写（机器人帮你自动晾衣服）</li><li>五种IO的模型：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO和异步IO, 前四种都是同步IO，在内核数据copy到用户空间时都是阻塞的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">权威：RFC标准，或者书籍 《UNIX Network Programming》中文名《UNIX网络编程-卷一》第六章</span><br><span class="line">    1）阻塞式I/O；</span><br><span class="line">    2）非阻塞式I/O；</span><br><span class="line">    3）I/O复用（select，poll，epoll...）；</span><br><span class="line"></span><br><span class="line">           I/O多路复用是阻塞在select，epoll这样的系统调用，没有阻塞在真正的I/O系统调用如recvfrom</span><br><span class="line">           进程受阻于select,等待可能多个套接口中的任一个变为可读</span><br><span class="line">   </span><br><span class="line">           IO多路复用使用两个系统调用(select和recvfrom)</span><br><span class="line">           blocking IO只调用了一个系统调用(recvfrom)</span><br><span class="line">           select/epoll 核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO好</span><br><span class="line">           多路复用模型中，每一个socket，设置为non-blocking,</span><br><span class="line">           阻塞是被select这</span><br></pre></td></tr></table></figure><p> I/O复用<img src="C:%5CUsers%5C86183%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200911140006930.png" alt="image-20200911140006930"></p><h3 id="3、-BAT面试核心知识-Linux网络编程中的五种I-O模型讲解下集"><a href="#3、-BAT面试核心知识-Linux网络编程中的五种I-O模型讲解下集" class="headerlink" title="3、(BAT面试核心知识)Linux网络编程中的五种I/O模型讲解下集"></a>3、(BAT面试核心知识)Linux网络编程中的五种I/O模型讲解下集</h3><p><strong>简介：linux网络编程中的IO模型讲解下集</strong></p><ul><li>4）信号驱动式I/O（SIGIO）；</li><li>5）异步I/O（POSIX的aio_系列函数） Future-Listener机制；</li><li>IO操作分为两步<ul><li>发起IO请求，等待数据准备(Waiting for the data to be ready)</li><li>实际的IO操作，将数据从内核拷贝到进程中(Copying the data from the kernel to the process)</li></ul></li><li>前四种IO模型都是同步IO操作，区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用或者select()函数。 相反，异步I/O模型在这两个阶段都要处理。</li><li>阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">几个核心点：</span><br><span class="line">   阻塞非阻塞说的是线程的状态（重要）</span><br><span class="line">   同步和异步说的是消息的通知机制（重要）</span><br><span class="line">   </span><br><span class="line">   同步需要主动读写数据,异步是不需要主动读写数据</span><br><span class="line">   同步IO和异步IO是针对用户应用程序和内核的交互</span><br></pre></td></tr></table></figure><h3 id="4、高并发编程必备知识IO多路复用技术select、poll讲解"><a href="#4、高并发编程必备知识IO多路复用技术select、poll讲解" class="headerlink" title="4、高并发编程必备知识IO多路复用技术select、poll讲解"></a>4、高并发编程必备知识IO多路复用技术select、poll讲解</h3><p><strong>简介：高并发编程必备知识IO多路复用技术select、poll讲解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">什么是IO多路复用：I/O多路复用，I/O是指网络I/O, 多路指多个TCP连接(即socket或者channel），复用指复用一个或几个线程。简单来说：就是使用一个或者几个线程处理多个TCP连接,最大优势是减少系统开销小，不必创建过多的进程/线程，也不必维护这些进程/线程</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select：</span><br><span class="line">    基本原理：监视文件3类描述符： writefds、readfds、和exceptfds,调用后select函数会阻塞住，等有数据 可读、可写、出异常 或者 超时 就会返回, select函数正常返回后，通过遍历fdset整个数组才能发现哪些句柄发生了事件，来找到就绪的描述符fd，然后进行对应的IO操作,几乎在所有的平台上支持，跨平台支持性好</span><br><span class="line">    </span><br><span class="line">缺点：</span><br><span class="line">    1）select采用轮询的方式扫描文件描述符，全部扫描，随着文件描述符FD数量增多而性能下降            </span><br><span class="line">    2）每次调用 select()，需要把 fd 集合从用户态拷贝到内核态，并进行遍历(消息传递都是从内核到用户空间)</span><br><span class="line">    3）最大的缺陷就是单个进程打开的FD有限制，默认是1024   （可修改宏定义，但是效率仍然慢）                </span><br><span class="line">    static final  int MAX_FD = 1024</span><br><span class="line">poll:</span><br><span class="line">    基本流程：</span><br><span class="line"> select() 和 poll() 系统调用的大体一样，处理多个描述符也是使用轮询的方式，根据描述符的状态进行处理,一样需要把 fd 集合从用户态拷贝到内核态，并进行遍历。最大区别是: poll没有最大文件描述符限制（使用链表的方式存储fd）</span><br></pre></td></tr></table></figure><h3 id="5、-高并发编程必备知识IO多路复用技术Epoll讲解和总结"><a href="#5、-高并发编程必备知识IO多路复用技术Epoll讲解和总结" class="headerlink" title="5、 高并发编程必备知识IO多路复用技术Epoll讲解和总结"></a>5、 高并发编程必备知识IO多路复用技术Epoll讲解和总结</h3><p><strong>简介：高并发编程必备知识IO多路复用技术epoll讲解和总结</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">epoll 基本原理：</span><br><span class="line">      在2.6内核中提出的，对比select和poll，epoll更加灵活，没有描述符限制，用户态拷贝到内核态只需要一次</span><br><span class="line">      使用事件通知，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用callback的回调机制来激活对应的fd</span><br><span class="line">    </span><br><span class="line">      优点：</span><br><span class="line">          1)没fd这个限制，所支持的FD上限是操作系统的最大文件句柄数，1G内存大概支持10万个句柄 </span><br><span class="line">          2)效率提高，使用回调通知而不是轮询的方式，不会随着FD数目的增加效率下降</span><br><span class="line">          3)通过callback机制通知，内核和用户空间mmap同一块内存实现</span><br><span class="line">   </span><br><span class="line">          Linux内核核心函数</span><br><span class="line">          1)epoll_create()  在Linux内核里面申请一个文件系统 B+树，返回epoll对象，也是一个fd</span><br><span class="line">          2)epoll_ctl() 操作epoll对象，在这个对象里面修改添加删除对应的链接fd, 绑定一个callback函数</span><br><span class="line">          3)epoll_wait()  判断并完成对应的IO操作</span><br><span class="line">   </span><br><span class="line">      缺点：</span><br><span class="line">          编程模型比select/poll 复杂</span><br><span class="line">          例子：100万个连接，里面有1万个连接是活跃，在 select、poll、epoll分别是怎样的表现                </span><br><span class="line">          select：不修改宏定义，则需要 1000个进程才可以支持 100万连接</span><br><span class="line">          poll：100万个链接，遍历都响应不过来了，还有空间的拷贝消耗大量的资源</span><br><span class="line">          epoll:</span><br></pre></td></tr></table></figure><h3 id="6、Java的I-O演进历史"><a href="#6、Java的I-O演进历史" class="headerlink" title="6、Java的I/O演进历史"></a>6、Java的I/O演进历史</h3><p><strong>简介：讲解java的IO演进历史</strong></p><ul><li>jdk1.4之前是采用同步阻塞模型，也就是BIO 大型服务一般采用C或者C++, 因为可以直接操作系统提供的异步IO,AIO</li><li>jdk1.4推出NIO,支持非阻塞IO，jdk1.7升级,推出NIO2.0,提供AIO的功能，支持文件和网络套接字的异步IO</li></ul><h3 id="7、大话Netty线程模型和Reactor模式"><a href="#7、大话Netty线程模型和Reactor模式" class="headerlink" title="7、大话Netty线程模型和Reactor模式"></a>7、大话Netty线程模型和Reactor模式</h3><p><strong>简介：讲解reactor模式 和 Netty线程模型</strong></p><ul><li>设计模式——Reactor模式（反应器设计模式），是一种基于事件驱动的设计模式，在事件驱动的应用中，将一个或多个客户的服务请求分离（demultiplex）和调度（dispatch）给应用程序。在事件驱动的应用中，同步地、有序地处理同时接收的多个服务请求 一般出现在高并发系统中，比如Netty，Redis等</li><li>优点 1）响应快，不会因为单个同步而阻塞，虽然Reactor本身依然是同步的； 2）编程相对简单，最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销； 3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；</li><li>缺点 1）相比传统的简单模型，Reactor增加了一定的复杂性，因而有一定的门槛，并且不易于调试。 2）Reactor模式需要系统底层的的支持，比如Java中的Selector支持，操作系统的select系统调用支持</li><li>通俗理解：KTV例子 前台接待，服务人员带领去开机器</li><li>Reactor模式基于事件驱动，适合处理海量的I/O事件，属于同步非阻塞IO(NIO)</li><li>Reactor单线程模型(比较少用)<ul><li>内容： 1）作为NIO服务端，接收客户端的TCP连接；作为NIO客户端，向服务端发起TCP连接； 2）服务端读请求数据并响应；客户端写请求并读取响应</li><li>使用场景: 对应小业务则适合，编码简单；对于高负载、大并发的应用场景不适合，一个NIO线程处理太多请求，则负载过高，并且可能响应变慢，导致大量请求超时，而且万一线程挂了，则不可用了</li></ul></li><li>Reactor多线程模型<ul><li>内容：Acceptor不在是一个线程，而是一组NIO线程；IO线程也是一组NIO线程，这样就是两个线程池去处理接入连接和处理IO</li><li>使用场景：满足目前的大部分场景，也是Netty推荐使用的线程模型</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">附属资料：</span><br><span class="line">  为什么Netty使用NIO而不是AIO，是同步非阻塞还是异步非阻塞？</span><br><span class="line">            </span><br><span class="line">  答案：</span><br><span class="line">  在Linux系统上，AIO的底层实现仍使用EPOLL，与NIO相同，因此在性能上没有明显的优势</span><br><span class="line">  Netty整体架构是reactor模型，采用epoll机制，所以往深的说，还是IO多路复用模式，所以也可说netty是同步非阻塞模型（看的层次不一样）</span><br><span class="line"></span><br><span class="line">  很多人说这是netty是基于Java NIO 类库实现的异步通讯框架</span><br><span class="line">  特点：异步非阻塞、基于事件驱动，性能高，高可靠性和高可定制性。</span><br><span class="line">    </span><br><span class="line">  参考资料：</span><br><span class="line">   https://github.com/netty/netty/issues/2515</span><br></pre></td></tr></table></figure><hr><h2 id="第四章：高并发网络编程Netty的第一个案例"><a href="#第四章：高并发网络编程Netty的第一个案例" class="headerlink" title="第四章：高并发网络编程Netty的第一个案例"></a>第四章：高并发网络编程Netty的第一个案例</h2><h3 id="1、讲解什么是Echo服务和Netty项目搭建"><a href="#1、讲解什么是Echo服务和Netty项目搭建" class="headerlink" title="1、讲解什么是Echo服务和Netty项目搭建"></a>1、讲解什么是Echo服务和Netty项目搭建</h3><p><strong>简介：讲解什么是Echo服务和快速创建Netty项目</strong></p><ul><li>什么是Echo服务：就是一个应答服务（回显服务器），客户端发送什么数据，服务端就响应的对应的数据是一个非常有的用于调试和检测的服务</li><li>IDEA + Maven + jdk8 netty依赖包</li><li>maven地址：<a href="https://mvnrepository.com/artifact/io.netty/netty-all/4.1.32.Final" target="_blank" rel="noopener">https://mvnrepository.com/artifact/io.netty/netty-all/4.1.32.Final</a></li></ul><h3 id="2、Netty实战之Echo服务-服务端程序编写实战"><a href="#2、Netty实战之Echo服务-服务端程序编写实战" class="headerlink" title="2、Netty实战之Echo服务-服务端程序编写实战"></a>2、Netty实战之Echo服务-服务端程序编写实战</h3><p><strong>简介：讲解Echo服务-服务端程序编写实战，对应的启动类和handler处理器</strong></p><h3 id="3、Netty实战之Echo服务-客户端程序编写实战"><a href="#3、Netty实战之Echo服务-客户端程序编写实战" class="headerlink" title="3、Netty实战之Echo服务-客户端程序编写实战"></a>3、Netty实战之Echo服务-客户端程序编写实战</h3><p><strong>简介：讲解Echo服务客户端程序编写</strong></p><h4 id="4、Netty实战之Echo服务演示和整个流程分析"><a href="#4、Netty实战之Echo服务演示和整个流程分析" class="headerlink" title="4、Netty实战之Echo服务演示和整个流程分析"></a>4、Netty实战之Echo服务演示和整个流程分析</h4><p><strong>简介：分析整个Echo服务各个组件名称和作用</strong></p><ul><li>EventLoop和EventLoopGroup</li><li>Bootstrapt启动引导类</li><li>Channel 生命周期，状态变化</li><li>ChannelHandler和ChannelPipline</li></ul><hr><h2 id="第五章：Netty案例实战分析之核心链路源码讲解"><a href="#第五章：Netty案例实战分析之核心链路源码讲解" class="headerlink" title="第五章：Netty案例实战分析之核心链路源码讲解"></a>第五章：Netty案例实战分析之核心链路源码讲解</h2><h3 id="1、深入剖析EventLoop和EventLoopGroup线程模型"><a href="#1、深入剖析EventLoop和EventLoopGroup线程模型" class="headerlink" title="1、深入剖析EventLoop和EventLoopGroup线程模型"></a>1、深入剖析EventLoop和EventLoopGroup线程模型</h3><p><strong>简介：源码讲解EventLoop和EventLoopGroup模块</strong></p><ul><li>高性能RPC框架的3个要素：IO模型、数据协议、线程模型</li><li>EventLoop好比一个线程，1个EventLoop可以服务多个Channel，1个Channel只有一个EventLoop可以创建多个 EventLoop 来优化资源利用，也就是EventLoopGroup</li><li>EventLoopGroup 负责分配 EventLoop 到新创建的 Channel，里面包含多个EventLoop<ul><li>EventLoopGroup -&gt; 多个 EventLoop ,EventLoop -&gt; 维护一个 Selector</li><li>学习资料：<a href="http://ifeve.com/selectors/" target="_blank" rel="noopener">http://ifeve.com/selectors/</a></li></ul></li><li>源码分析默认线程池数量</li></ul><h3 id="2、Netty启动引导类Bootstrap模块讲解"><a href="#2、Netty启动引导类Bootstrap模块讲解" class="headerlink" title="2、Netty启动引导类Bootstrap模块讲解"></a>2、Netty启动引导类Bootstrap模块讲解</h3><p><strong>简介：讲解Netty启动引导类Bootstrap作用和tcp通道参数设置</strong></p><ul><li>服务器启动引导类ServerBootstrap<ul><li>group :设置线程组模型，Reactor线程模型对比EventLoopGroup<ul><li>单线程</li><li>多线程</li><li>主从线程</li><li>参考：<a href="https://blog.csdn.net/QH_JAVA/article/details/78443646" target="_blank" rel="noopener">https://blog.csdn.net/QH_JAVA/article/details/78443646</a></li></ul></li><li>channel：设置channel通道类型NioServerSocketChannel、OioServerSocketChannel</li><li>option: 作用于每个新建立的channel，设置TCP连接中的一些参数,如下<ul><li>ChannelOption.SO_BACKLOG: 存放已完成三次握手的请求的等待队列的最大长度;</li><li>Linux服务器TCP连接底层知识：<ul><li>syn queue：半连接队列，洪水攻击，tcp_max_syn_backlog</li><li>accept queue：全连接队列， net.core.somaxconn</li></ul></li><li>系统默认的somaxconn参数要足够大 ，如果backlog比somaxconn大，则会优先用后者 <a href="https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/NetUtil.java#L250" target="_blank" rel="noopener">https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/NetUtil.java#L250</a></li><li>ChannelOption.TCP_NODELAY: 为了解决Nagle的算法问题，默认是false, 要求高实时性，有数据时马上发送，就将该选项设置为true关闭Nagle算法；如果要减少发送次数，就设置为false，会累积一定大小后再发送</li><li>知识拓展： <a href="https://baike.baidu.com/item/Nagle算法/5645172" target="_blank" rel="noopener">https://baike.baidu.com/item/Nagle%E7%AE%97%E6%B3%95/5645172</a> <a href="https://www.2cto.com/article/201309/241096.html" target="_blank" rel="noopener">https://www.2cto.com/article/201309/241096.html</a></li></ul></li><li>childOption: 作用于被accept之后的连接</li><li>childHandler: 用于对每个通道里面的数据处理</li></ul></li><li>客户端启动引导类Bootstrap<ul><li>remoteAddress： 服务端地址</li><li>handler：和服务端通信的处理器</li></ul></li></ul><h3 id="3、Netty核心组件Channel模块讲解"><a href="#3、Netty核心组件Channel模块讲解" class="headerlink" title="3、Netty核心组件Channel模块讲解"></a>3、Netty核心组件Channel模块讲解</h3><p><strong>简介:讲解Channel作用，核心模块知识点，生命周期等</strong></p><ul><li><p>什么是Channel: 客户端和服务端建立的一个连接通道</p></li><li><p>什么是ChannelHandler： 负责Channel的逻辑处理</p></li><li><p>什么是ChannelPipeline: 负责管理ChannelHandler的有序容器</p></li><li><p>他们是什么关系:</p><ul><li>一个Channel包含一个ChannelPipeline，所有ChannelHandler都会顺序加入到ChannelPipeline中 创建Channel时会自动创建一个ChannelPipeline，每个Channel都有一个管理它的pipeline，这关联是永久性的</li></ul></li><li><p>Channel当状态出现变化，就会触发对应的事件</p><ul><li><p>状态：</p><ul><li><p>channelRegistered: channel注册到一个EventLoop</p></li><li><p>channelActive: 变为活跃状态（连接到了远程主机），可以接受和发送数据</p></li><li><p>channelInactive: channel处于非活跃状态，没有连接到远程主机</p></li><li><p>channelUnregistered: channel已经创建，但是未注册到一个EventLoop里面，也就是没有和Selector绑定</p></li></ul></li></ul></li></ul><h3 id="4、ChannelHandler和ChannelPipeline模块讲解"><a href="#4、ChannelHandler和ChannelPipeline模块讲解" class="headerlink" title="4、ChannelHandler和ChannelPipeline模块讲解"></a>4、ChannelHandler和ChannelPipeline模块讲解</h3><p><strong>简介：讲解ChannelHandler和ChannelPipeline核心作用和生命周期</strong></p><ul><li>方法: handlerAdded : 当 ChannelHandler 添加到 ChannelPipeline 调用 handlerRemoved : 当 ChannelHandler 从 ChannelPipeline 移除时调用 exceptionCaught : 执行抛出异常时调用</li></ul><ul><li>ChannelHandler下主要是两个子接口<ul><li>ChannelInboundHandler：(入站) 处理输入数据和Channel状态类型改变， 适配器 ChannelInboundHandlerAdapter（适配器设计模式） 常用的：SimpleChannelInboundHandler</li><li>ChannelOutboundHandler：(出站) 处理输出数据，适配器 ChannelOutboundHandlerAdapter</li></ul></li></ul><ul><li>ChannelPipeline： 好比厂里的流水线一样，可以在上面添加多个ChannelHanler，也可看成是一串 ChannelHandler 实例，拦截穿过 Channel 的输入输出 event, ChannelPipeline 实现了拦截器的一种高级形式，使得用户可以对事件的处理以及ChannelHanler之间交互获得完全的控制权</li></ul><h3 id="5、Netty核心模块指ChannelHandlerContext模块讲解"><a href="#5、Netty核心模块指ChannelHandlerContext模块讲解" class="headerlink" title="5、Netty核心模块指ChannelHandlerContext模块讲解"></a>5、Netty核心模块指ChannelHandlerContext模块讲解</h3><p><strong>简介：讲解ChannelHandlerContext模块的作用和分析</strong></p><ul><li>ChannelHandlerContext是连接ChannelHandler和ChannelPipeline的桥梁，ChannelHandlerContext部分方法和Channel及ChannelPipeline重合,好比调用write方法<ul><li>Channel、ChannelPipeline、ChannelHandlerContext 都可以调用此方法，前两者都会在整个管道流里传播，而ChannelHandlerContext就只会在后续的Handler里面传播</li></ul></li><li>AbstractChannelHandlerContext类双向链表结构，next/prev分别是后继节点，和前驱节点</li><li>DefaultChannelHandlerContext 是实现类，但是大部分都是父类那边完成，这个只是简单的实现一些方法 主要就是判断Handler的类型</li><li>ChannelInboundHandler之间的传递，主要通过调用ctx里面的FireXXX()方法来实现下个handler的调用</li></ul><h3 id="6、Netty案例实战常见问题之入站出站Handler执行顺序"><a href="#6、Netty案例实战常见问题之入站出站Handler执行顺序" class="headerlink" title="6、Netty案例实战常见问题之入站出站Handler执行顺序"></a>6、Netty案例实战常见问题之入站出站Handler执行顺序</h3><p><strong>简介: 讲解多个入站出站ChannelHandler的执行顺序</strong></p><p>1、一般的项目中，inboundHandler和outboundHandler有多个，在Pipeline中的执行顺序？ InboundHandler顺序执行，OutboundHandler逆序执行 问题：ch.pipeline().addLast(new InboundHandler1()); ch.pipeline().addLast(new OutboundHandler1()); ch.pipeline().addLast(new OutboundHandler2()); ch.pipeline().addLast(new InboundHandler2()); 或者： ch.pipeline().addLast(new OutboundHandler1()); ch.pipeline().addLast(new OutboundHandler2()); ch.pipeline().addLast(new InboundHandler1()); ch.pipeline().addLast(new InboundHandler2()); 执行顺序是： InboundHandler1 channelRead InboundHandler2 channelRead OutboundHandler2 write OutboundHandler1 write</p><p>结论：</p><ul><li>InboundHandler顺序执行，OutboundHandler逆序执行</li><li>InboundHandler之间传递数据，通过ctx.fireChannelRead(msg)</li><li>InboundHandler通过ctx.write(msg)，则会传递到outboundHandler</li><li>使用ctx.write(msg)传递消息，Inbound需要放在结尾，在Outbound之后，不然outboundhandler会不执行；但是使用channel.write(msg)、pipline.write(msg)情况会不一致，都会执行</li><li>outBound和Inbound谁先执行，针对客户端和服务端而言，客户端是发起请求再接受数据，先outbound再inbound，服务端则相反</li></ul><h3 id="7、Netty异步操作模块ChannelFuture讲解"><a href="#7、Netty异步操作模块ChannelFuture讲解" class="headerlink" title="7、Netty异步操作模块ChannelFuture讲解"></a>7、Netty异步操作模块ChannelFuture讲解</h3><p><strong>简介：讲解ChannelFuture异步操作模块及使用注意事项</strong></p><ul><li>Netty中的所有I/O操作都是异步的,这意味着任何I/O调用都会立即返回，而ChannelFuture会提供有关的信息I/O操作的结果或状态。</li><li>ChannelFuture状态<ul><li>未完成：当I/O操作开始时，将创建一个新的对象，新的最初是未完成的 - 它既没有成功，也没有成功，也没有被取消，因为I/O操作尚未完成。</li><li>已完成：当I/O操作完成，不管是成功、失败还是取消，Future都是标记为已完成的, 失败的时候也有具体的信息，例如原因失败，但请注意，即使失败和取消属于完成状态</li><li>注意：不要在IO线程内调用future对象的sync或者await方法。不能在channelHandler中调用sync或者await方法</li></ul></li><li>ChannelPromise：继承于ChannelFuture，进一步拓展用于设置IO操作的结果</li></ul><hr><h2 id="第六章：高并发架构之Netty网络数据传输编解码精讲"><a href="#第六章：高并发架构之Netty网络数据传输编解码精讲" class="headerlink" title="第六章：高并发架构之Netty网络数据传输编解码精讲"></a>第六章：高并发架构之Netty网络数据传输编解码精讲</h2><h3 id="1、Netty网络传输知识之什么是编码、解码"><a href="#1、Netty网络传输知识之什么是编码、解码" class="headerlink" title="1、Netty网络传输知识之什么是编码、解码"></a>1、Netty网络传输知识之什么是编码、解码</h3><p><strong>简介：讲解Netty编写的网络数据传输中的编码和解码</strong></p><ul><li><p>前面说的：高性能RPC框架的3个要素：IO模型、数据协议、线程模型</p></li><li><p>最开始接触的编码码：java序列化/反序列化（就是编解码）、url编码、base64编解码</p></li><li><p>为啥jdk有编解码，还要netty自己开发编解码？</p><ul><li><p>java自带序列化的缺点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）无法跨语言</span><br><span class="line">2) 序列化后的码流太大，也就是数据包太大</span><br><span class="line">3) 序列化和反序列化性能比较差</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>业界里面也有其他编码框架： google的 protobuf（PB)、Facebook的Trift、Jboss的Marshalling、Kyro等</p></li><li><p>Netty里面的编解码：</p><ul><li><p>解码器：负责处理“入站 InboundHandler”数据</p></li><li><p>编码器：负责“出站 OutboundHandler” 数据</p></li><li><p>Netty里面提供默认的编解码器，也支持自定义编解码器</p><ul><li>Encoder:编码器</li><li>Decoder:解码器</li><li>Codec:编解码器</li></ul></li></ul></li></ul><h3 id="2、数据协议处理之Netty解码器Decoder讲解"><a href="#2、数据协议处理之Netty解码器Decoder讲解" class="headerlink" title="2、数据协议处理之Netty解码器Decoder讲解"></a>2、数据协议处理之Netty解码器Decoder讲解</h3><p><strong>简介:讲解Netty的解码器Decoder和使用场景</strong></p><ul><li><p>Decoder对应的就是ChannelInboundHandler，主要就是字节数组转换为消息对象</p></li><li><p>主要是两个方法 decode decodeLast</p></li><li><p>抽象解码器</p><ul><li>ByteToMessageDecoder用于将字节转为消息，需要检查缓冲区是否有足够的字节</li><li>ReplayingDecoder继承ByteToMessageDecoder，不需要检查缓冲区是否有足够的字节，但是ReplayingDecoder速度略满于ByteToMessageDecoder，不是所有的ByteBuf都支持</li><li>选择：项目复杂性高则使用ReplayingDecoder，否则使用 ByteToMessageDecoder</li><li>MessageToMessageDecoder用于从一种消息解码为另外一种消息（例如POJO到POJO）</li></ul></li></ul><ul><li><p>解码器具体的实现，用的比较多的是(更多是为了解决TCP底层的粘包和拆包问题)</p><ul><li>DelimiterBasedFrameDecoder： 指定消息分隔符的解码器</li><li>LineBasedFrameDecoder: 以换行符为结束标志的解码器</li><li>FixedLengthFrameDecoder：固定长度解码器</li><li>LengthFieldBasedFrameDecoder：message = header+body, 基于长度解码的通用解码器</li><li>StringDecoder：文本解码器，将接收到的对象转化为字符串，一般会与上面的进行配合，然后在后面添加业务handle</li></ul></li></ul><h3 id="3、数据协议处理之Netty编码器Encoder讲解"><a href="#3、数据协议处理之Netty编码器Encoder讲解" class="headerlink" title="3、数据协议处理之Netty编码器Encoder讲解"></a>3、数据协议处理之Netty编码器Encoder讲解</h3><p><strong>简介：讲解Netty编码器Encoder</strong></p><ul><li>Encoder对应的就是ChannelOutboundHandler，消息对象转换为字节数组</li><li>Netty本身未提供和解码一样的编码器，是因为场景不同，两者非对等的</li><li>MessageToByteEncoder消息转为字节数组,调用write方法，会先判断当前编码器是否支持需要发送的消息类型，如果不支持，则透传；</li><li>MessageToMessageEncoder用于从一种消息编码为另外一种消息（例如POJO到POJO）</li></ul><h3 id="4、数据协议处理之Netty编解码器类Codec讲解"><a href="#4、数据协议处理之Netty编解码器类Codec讲解" class="headerlink" title="4、数据协议处理之Netty编解码器类Codec讲解"></a>4、数据协议处理之Netty编解码器类Codec讲解</h3><p><strong>简介：讲解组合编解码器类Codec</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">组合解码器和编码器，以此提供对于字节和消息都相同的操作</span><br><span class="line">   </span><br><span class="line">    优点：成对出现，编解码都是在一个类里面完成    </span><br><span class="line">    缺点：耦合在一起，拓展性不佳</span><br><span class="line"></span><br><span class="line">    Codec:组合编解码</span><br><span class="line">        1）ByteToMessageCodec</span><br><span class="line"></span><br><span class="line">        2）MessageToMessageCodec</span><br><span class="line"></span><br><span class="line">    decoder:解码</span><br><span class="line">         1）ByteToMessageDecoder</span><br><span class="line"></span><br><span class="line">         2）MessageToMessageDecoder</span><br><span class="line">    </span><br><span class="line">    encoder:编码</span><br><span class="line">         1）ByteToMessageEncoder</span><br><span class="line"></span><br><span class="line">        2）MessageToMessageEncoder</span><br></pre></td></tr></table></figure><hr><h2 id="第七章、Netty核心知识之网络传输TCP粘包拆包"><a href="#第七章、Netty核心知识之网络传输TCP粘包拆包" class="headerlink" title="第七章、Netty核心知识之网络传输TCP粘包拆包"></a>第七章、Netty核心知识之网络传输TCP粘包拆包</h2><h3 id="1、网络编程核心知识之TCP粘包拆包讲解"><a href="#1、网络编程核心知识之TCP粘包拆包讲解" class="headerlink" title="1、网络编程核心知识之TCP粘包拆包讲解"></a>1、网络编程核心知识之TCP粘包拆包讲解</h3><p><strong>简介：讲解什么是TCP粘包拆包讲解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1）TCP拆包: 一个完整的包可能会被TCP拆分为多个包进行发送</span><br><span class="line">2）TCP粘包: 把多个小的包封装成一个大的数据包发送, client发送的若干数据包 Server接收时粘成一包</span><br><span class="line">    </span><br><span class="line">发送方和接收方都可能出现这个原因</span><br><span class="line">        </span><br><span class="line">发送方的原因：TCP默认会使用Nagle算法</span><br><span class="line">        </span><br><span class="line">接收方的原因: TCP接收到数据放置缓存中，应用程序从缓存中读取 </span><br><span class="line">       </span><br><span class="line">UDP: 是没有粘包和拆包的问题，有边界协议</span><br></pre></td></tr></table></figure><h3 id="2、TCP半包读写常见解决方案"><a href="#2、TCP半包读写常见解决方案" class="headerlink" title="2、TCP半包读写常见解决方案"></a>2、TCP半包读写常见解决方案</h3><p><strong>简介：讲解TCP半包读写常见的解决办法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">发送方：可以关闭Nagle算法</span><br><span class="line">      接受方: TCP是无界的数据流，并没有处理粘包现象的机制, 且协议本身无法避免粘包，半包读写的发生需要在应用层进行处理</span><br><span class="line">     应用层解决半包读写的办法</span><br><span class="line">     1）设置定长消息 (10字符)</span><br><span class="line">        xdclass000xdclass000xdclass000xdclass000</span><br><span class="line">                        </span><br><span class="line">     2）设置消息的边界 ($$ 切割)</span><br><span class="line">        sdfafwefqwefwe$$dsafadfadsfwqehidwuehfiw$$879329832r89qweew$$</span><br><span class="line">    </span><br><span class="line">     3）使用带消息头的协议，消息头存储消息开始标识及消息的长度信息</span><br><span class="line">        Header+Body</span><br></pre></td></tr></table></figure><h3 id="3、Netty自带解决TCP半包读写方案"><a href="#3、Netty自带解决TCP半包读写方案" class="headerlink" title="3、Netty自带解决TCP半包读写方案"></a>3、Netty自带解决TCP半包读写方案</h3><p><strong>简介：讲解Netty自带解决半包读写问题方案介绍</strong></p><p>DelimiterBasedFrameDecoder： 指定消息分隔符的解码器 LineBasedFrameDecoder: 以换行符为结束标志的解码器 FixedLengthFrameDecoder：固定长度解码器 LengthFieldBasedFrameDecoder：message = header+body, 基于长度解码的通用解码器</p><h3 id="4、Netty案例实战之半包读写问题演示"><a href="#4、Netty案例实战之半包读写问题演示" class="headerlink" title="4、Netty案例实战之半包读写问题演示"></a>4、Netty案例实战之半包读写问题演示</h3><p><strong>简介：案例实战之使用netty进行开发，出现的TCP半包读写问题</strong></p><h3 id="5、Netty案例实战之LineBasedFrameDecoder解决TCP半包读写"><a href="#5、Netty案例实战之LineBasedFrameDecoder解决TCP半包读写" class="headerlink" title="5、Netty案例实战之LineBasedFrameDecoder解决TCP半包读写"></a>5、Netty案例实战之LineBasedFrameDecoder解决TCP半包读写</h3><p><strong>简介：讲解使用解码器LineBasedFrameDecoder解决半包读写问题</strong></p><p>1）LineBaseFrameDecoder 以换行符为结束标志的解码器 ,构造函数里面的数字表示最长遍历的帧数</p><p>2）StringDecoder解码器将对象转成字符串</p><h3 id="6、Netty案例实战之自定义分隔符解决TCP读写问题"><a href="#6、Netty案例实战之自定义分隔符解决TCP读写问题" class="headerlink" title="6、Netty案例实战之自定义分隔符解决TCP读写问题"></a>6、Netty案例实战之自定义分隔符解决TCP读写问题</h3><p><strong>简介：讲解使用DelimiterBasedFrameDecoder解决TCP半包读写问题</strong></p><ul><li>maxLength：表示一行最大的长度，如果超过这个长度依然没有检测自定义分隔符，将会抛出TooLongFrameException</li><li>failFast：如果为true，则超出maxLength后立即抛出TooLongFrameException，不进行继续解码.如果为false，则等到完整的消息被解码后，再抛出TooLongFrameException异常</li><li>stripDelimiter：解码后的消息是否去除掉分隔符</li><li>delimiters：分隔符，ByteBuf类型</li></ul><h3 id="7、自定义长度半包读写器LengthFieldBasedFrameDecoder讲解"><a href="#7、自定义长度半包读写器LengthFieldBasedFrameDecoder讲解" class="headerlink" title="7、自定义长度半包读写器LengthFieldBasedFrameDecoder讲解"></a>7、自定义长度半包读写器LengthFieldBasedFrameDecoder讲解</h3><p><strong>简介：自定义长度半包读写器LengthFieldBasedFrameDecoder讲解</strong></p><p>官方文档：<a href="https://netty.io/4.0/api/io/netty/handler/codec/LengthFieldBasedFrameDecoder.html" target="_blank" rel="noopener">https://netty.io/4.0/api/io/netty/handler/codec/LengthFieldBasedFrameDecoder.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">maxFrameLength 数据包的最大长度</span><br><span class="line"></span><br><span class="line">lengthFieldOffset 长度字段的偏移位，长度字段开始的地方，意思是跳过指定长度个字节之后的才是消息体字段</span><br><span class="line"></span><br><span class="line">lengthFieldLength 长度字段占的字节数, 帧数据长度的字段本身的长度</span><br><span class="line"></span><br><span class="line">lengthAdjustment </span><br><span class="line">一般 Header + Body，添加到长度字段的补偿值,如果为负数，开发人员认为这个 Header的长度字段是整个消息包的长度，则Netty应该减去对应的数字</span><br><span class="line"></span><br><span class="line">initialBytesToStrip 从解码帧中第一次去除的字节数, 获取完一个完整的数据包之后，忽略前面的指定位数的长度字节，应用解码器拿到的就是不带长度域的数据包</span><br><span class="line"></span><br><span class="line">failFast 是否快速失败</span><br></pre></td></tr></table></figure><hr><h2 id="第八-Netty源码分析之基础数据传输讲解和设计模式"><a href="#第八-Netty源码分析之基础数据传输讲解和设计模式" class="headerlink" title="第八 Netty源码分析之基础数据传输讲解和设计模式"></a>第八 Netty源码分析之基础数据传输讲解和设计模式</h2><h3 id="1、Netty核心模块缓冲ByteBuf"><a href="#1、Netty核心模块缓冲ByteBuf" class="headerlink" title="1、Netty核心模块缓冲ByteBuf"></a>1、Netty核心模块缓冲ByteBuf</h3><p><strong>简介：讲解Netty核心之ByteBuf介绍，对比JDK原生ByteBuffer</strong></p><ul><li>ByteBuf：是数据容器(字节容器)</li><li>JDK ByteBuffer:共用读写索引，每次读写操作都需要Flip()扩容麻烦，而且扩容后容易造成浪费</li><li>Netty ByteBuf: 读写使用不同的索引，所以操作便捷自动扩容，使用便捷</li></ul><h3 id="2、Netty数据存储模块ByteBuf创建方法和常用的模式"><a href="#2、Netty数据存储模块ByteBuf创建方法和常用的模式" class="headerlink" title="2、Netty数据存储模块ByteBuf创建方法和常用的模式"></a>2、Netty数据存储模块ByteBuf创建方法和常用的模式</h3><p><strong>简介:讲解ByteBuf创建方法和常用的模式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf：传递字节数据的容器</span><br><span class="line"> </span><br><span class="line">ByteBuf的创建方法</span><br><span class="line">1）ByteBufAllocator</span><br><span class="line">   池化(Netty4.x版本后默认使用 PooledByteBufAllocator提高性能并且最大程度减少内存碎片</span><br><span class="line"> </span><br><span class="line">   非池化UnpooledByteBufAllocator： 每次返回新的实例</span><br><span class="line"> </span><br><span class="line"> 2）Unpooled: 提供静态方法创建未池化的ByteBuf，可以创建堆内存和直接内存缓冲区</span><br><span class="line"></span><br><span class="line">  ByteBuf使用模式</span><br><span class="line">     堆缓存区HEAP BUFFER:</span><br><span class="line">        优点：存储在JVM的堆空间中，可以快速的分配和释放</span><br><span class="line">         缺点：每次使用前会拷贝到直接缓存区(也叫堆外内存)</span><br><span class="line"> </span><br><span class="line">     直接缓存区DIRECR BUFFER:</span><br><span class="line">         优点：存储在堆外内存上，堆外分配的直接内存，不会占用堆空间</span><br><span class="line">         缺点：内存的分配和释放，比在堆缓冲区更复杂</span><br><span class="line"> </span><br><span class="line">     复合缓冲区COMPOSITE BUFFER:</span><br><span class="line">         可以创建多个不同的ByteBuf，然后放在一起，但是只是一个视图</span><br><span class="line">      选择：大量IO数据读写，用“直接缓存区”； 业务消息编解码用“堆缓存区”</span><br></pre></td></tr></table></figure><h3 id="3、Netty里面的设计模式应用分析"><a href="#3、Netty里面的设计模式应用分析" class="headerlink" title="3、Netty里面的设计模式应用分析"></a>3、Netty里面的设计模式应用分析</h3><p><strong>简介：讲解设计模式的在Netty里面的应用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Builder构造器模式：ServerBootstap </span><br><span class="line"></span><br><span class="line">责任链设计模式：pipeline的事件传播</span><br><span class="line"> </span><br><span class="line">工厂模式： 创建Channel</span><br><span class="line"> </span><br><span class="line">适配器模式：HandlerAdapter</span><br><span class="line"></span><br><span class="line">推荐书籍：《Head First设计模式》</span><br></pre></td></tr></table></figure><hr><h2 id="第九章-使用Netty搭建单机百万连接测试实战"><a href="#第九章-使用Netty搭建单机百万连接测试实战" class="headerlink" title="第九章 使用Netty搭建单机百万连接测试实战"></a>第九章 使用Netty搭建单机百万连接测试实战</h2><h3 id="1、搭建单机百万连接的服务器实例的必备知识"><a href="#1、搭建单机百万连接的服务器实例的必备知识" class="headerlink" title="1、搭建单机百万连接的服务器实例的必备知识"></a>1、搭建单机百万连接的服务器实例的必备知识</h3><p><strong>简介：搭建单机百万连接的服务器实例的必备知识</strong></p><ul><li>网络IO模型</li><li>Linux文件描述符<ul><li>单进程文件句柄数(默认1024，不同系统不一样，每个进程都有最大的文件描述符限制)</li><li>全局文件句柄数</li></ul></li><li>如何确定一个唯一的TCP连接. TCP四元组:源IP地址、源端口、目的ip、目的端口</li></ul><h3 id="2、Netty单机百万连接实战之服务端代码编写"><a href="#2、Netty单机百万连接实战之服务端代码编写" class="headerlink" title="2、Netty单机百万连接实战之服务端代码编写"></a>2、Netty单机百万连接实战之服务端代码编写</h3><p><strong>简介：讲解Netty单机百万连接服务端代码编写</strong></p><h3 id="3、Netty单机百万连接实战之客户端代码编写"><a href="#3、Netty单机百万连接实战之客户端代码编写" class="headerlink" title="3、Netty单机百万连接实战之客户端代码编写"></a>3、Netty单机百万连接实战之客户端代码编写</h3><p><strong>简介：讲解Netty单机百万连接之客户端代码编写</strong></p><h3 id="4、阿里云服务器Netty单机百万连接部署实战"><a href="#4、阿里云服务器Netty单机百万连接部署实战" class="headerlink" title="4、阿里云服务器Netty单机百万连接部署实战"></a>4、阿里云服务器Netty单机百万连接部署实战</h3><p><strong>简介：在阿里云服务器部署Netty服务端和Netty客户端代码</strong></p><ul><li>如果没条件，则自己搭建虚拟机 6G，4核，centos6.5/7,需要关闭防火墙，或者使用云服务器需要开放安全组）</li><li>服务端 47.107.143.89</li><li>客户端 120.25.93.69</li><li>windows: wscp图形界面，putty终端</li></ul><h3 id="5、Netty单机百万连接Linux内核参数优化"><a href="#5、Netty单机百万连接Linux内核参数优化" class="headerlink" title="5、Netty单机百万连接Linux内核参数优化"></a>5、Netty单机百万连接Linux内核参数优化</h3><p><strong>简介：单机百万连接Linux核心参数优化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">局部文件句柄限制（单个进程最大文件打开数）</span><br><span class="line">    ulimit -n 一个进程最大打开的文件数 fd 不同系统有不同的默认值</span><br><span class="line"></span><br><span class="line">    root身份编辑   vim /etc/security/limits.conf</span><br><span class="line">                增加下面</span><br><span class="line">                root soft nofile 1000000</span><br><span class="line">                root hard nofile 1000000</span><br><span class="line">                * soft nofile 1000000</span><br><span class="line">                * hard nofile 1000000</span><br><span class="line">    * 表示当前用户，修改后要重启</span><br><span class="line">    </span><br><span class="line">    全局文件句柄限制（所有进程最大打开的文件数，不同系统是不一样，可以直接echo临时修改）</span><br><span class="line">    查看命令</span><br><span class="line">        cat /proc/sys/fs/file-max</span><br><span class="line">    永久修改全局文件句柄, 修改后生效 sysctl -p</span><br><span class="line">        vim  /etc/sysctl.conf</span><br><span class="line">        增加 fs.file-max = 1000000</span><br><span class="line">    </span><br><span class="line">    启动</span><br><span class="line">        java -jar millionServer-1.0-SNAPSHOT.jar  -Xms5g -Xmx5g -XX:NewSize=3g -XX:MaxNewSize=3g</span><br></pre></td></tr></table></figure><h3 id="6、互联网架构数据链路分析总结"><a href="#6、互联网架构数据链路分析总结" class="headerlink" title="6、互联网架构数据链路分析总结"></a>6、互联网架构数据链路分析总结</h3><p><strong>简介：讲解当下互联网架构中，数据链路分析总结</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入域名-》浏览器内核调度-》本地DNS解析-》远程DNS解析-》ip -》路由多层调转-》目的服务器</span><br><span class="line">        服务器内核-》代理服务器 nginx/ 网关 / 负载均衡设备-》目的服务器</span><br><span class="line">        服务器内核-》 应用程序（springboot）-》Redis-》Mysql</span><br></pre></td></tr></table></figure><hr><h2 id="第十章：高并发系列之百万连接Netty实战课程总结"><a href="#第十章：高并发系列之百万连接Netty实战课程总结" class="headerlink" title="第十章：高并发系列之百万连接Netty实战课程总结"></a>第十章：高并发系列之百万连接Netty实战课程总结</h2><h3 id="1、高并发系列之百万连接Netty实战课程总结"><a href="#1、高并发系列之百万连接Netty实战课程总结" class="headerlink" title="1、高并发系列之百万连接Netty实战课程总结"></a>1、高并发系列之百万连接Netty实战课程总结</h3><p><strong>简介：总结Netty实战课程和第二季展望</strong></p><ul><li>websocket</li><li>推送系统</li><li>RPC框架</li><li>《Netty权威指南》《Netty进阶之路》</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第一章：高并发编程Netty&quot;&gt;&lt;a href=&quot;#第一章：高并发编程Netty&quot; class=&quot;headerlink&quot; title=&quot;第一章：高并发编程Netty&quot;&gt;&lt;/a&gt;第一章：高并发编程Netty&lt;/h2&gt;&lt;h3 id=&quot;1、高并发编程Netty框架&quot;&gt;&lt;a href=&quot;#1、高并发编程Netty框架&quot; class=&quot;headerlink&quot; title=&quot;1、高并发编程Netty框架&quot;&gt;&lt;/a&gt;1、高并发编程Netty框架&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;学习基础：&lt;br&gt;1、牢固的java基础&lt;/p&gt;
&lt;p&gt;2、熟悉Linux服务器&lt;/p&gt;
&lt;p&gt;3、有基础的网络知识&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2、异步事件驱动NIO框架Netty介绍&quot;&gt;&lt;a href=&quot;#2、异步事件驱动NIO框架Netty介绍&quot; class=&quot;headerlink&quot; title=&quot;2、异步事件驱动NIO框架Netty介绍&quot;&gt;&lt;/a&gt;2、异步事件驱动NIO框架Netty介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;简介：介绍Netty来源，版本，目前在哪些主流公司和产品框架使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Netty是由JBOSS提供的一个java开源框架, 是业界最流行的NIO框架，整合了多种协议（ 包括FTP、SMTP、HTTP等各种二进制文本协议）的实现经验，精心设计的框架，在多个大型商业项目中得到充分验证。 1）API使用简单 2）成熟、稳定 3）社区活跃 有很多种NIO框架 如mina 4）经过大规模的验证（互联网、大数据、网络游戏、电信通信行业）&lt;/p&gt;</summary>
    
    
    
    
    <category term="Netty" scheme="https://LiuHuAshen.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch在Springboot中的两种实现方式</title>
    <link href="https://liuhuashen.github.io/2020/06/21/ElasticSearch%E5%9C%A8Springboot%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
    <id>https://liuhuashen.github.io/2020/06/21/ElasticSearch%E5%9C%A8Springboot%E4%B8%AD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</id>
    <published>2020-06-21T13:47:57.000Z</published>
    <updated>2021-07-03T07:38:57.646Z</updated>
    
    <content type="html"><![CDATA[<p>1、jest<br>使用Maven依赖</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;io.searchbox&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jest&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.3.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>测试</p><p>使用注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JestClient jestClient;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">User user=<span class="keyword">new</span> User();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setGenter(<span class="number">1</span>);</span><br><span class="line">user.setUserName(<span class="string">"lhs"</span>);</span><br><span class="line">user.setAddress(<span class="string">"nanchang"</span>);</span><br><span class="line">Index build = <span class="keyword">new</span> Index.Builder(user).index(<span class="string">"nanchang"</span>).type(<span class="string">"student"</span>).build();</span><br><span class="line"></span><br><span class="line">jestClient.execute(build);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行搜索，搜索匹配到last_name为Smith的数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String query=<span class="string">"&#123;\n"</span> +</span><br><span class="line"><span class="string">"    \"query\" : &#123;\n"</span> +</span><br><span class="line"><span class="string">"        \"match\" : &#123;\n"</span> +</span><br><span class="line"><span class="string">"            \"last_name\" : \"Smith\"\n"</span> +</span><br><span class="line"><span class="string">"        &#125;\n"</span> +</span><br><span class="line"><span class="string">"    &#125;\n"</span> +</span><br><span class="line"><span class="string">"&#125;"</span>;</span><br><span class="line">Search build = <span class="keyword">new</span> Search.Builder(query).addIndex(<span class="string">"nanchang"</span>).addType(<span class="string">"student"</span>).build();</span><br><span class="line"></span><br><span class="line">SearchResult execute = jestClient.execute(build);</span><br><span class="line"></span><br><span class="line">System.out.println(execute);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>2、使用spring-boot-starter-data-elasticsearch实现</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span>  List&lt;Book&gt; <span class="title">findByBookNameLike</span><span class="params">(String bookName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">BookRepository bookRepository;</span><br><span class="line"><span class="comment">//添加数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addElasticSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Book book=<span class="keyword">new</span> Book();</span><br><span class="line">   <span class="comment">/* book.setBookId(1);</span></span><br><span class="line"><span class="comment">    book.setBookName("三国演义");</span></span><br><span class="line"><span class="comment">        book.setBookNo(10);*/</span></span><br><span class="line">        bookRepository.index(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searchBook</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Book&gt; listBook = bookRepository.findByBookNameLike(<span class="string">"三"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Book book1:listBook)&#123;</span><br><span class="line">            System.out.println(book1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、jest&lt;br&gt;使用Maven依赖&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;io.searchbox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;jest&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;version&amp;gt;5.3.3&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;测试&lt;/p&gt;
&lt;p&gt;使用注解&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;JestClient jestClient;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//添加数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;contextLoads&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		User user=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; User();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		user.setId(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		user.setGenter(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		user.setUserName(&lt;span class=&quot;string&quot;&gt;&quot;lhs&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		user.setAddress(&lt;span class=&quot;string&quot;&gt;&quot;nanchang&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Index build = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Index.Builder(user).index(&lt;span class=&quot;string&quot;&gt;&quot;nanchang&quot;&lt;/span&gt;).type(&lt;span class=&quot;string&quot;&gt;&quot;student&quot;&lt;/span&gt;).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		jestClient.execute(build);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//进行搜索，搜索匹配到last_name为Smith的数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testQuery&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		String query=&lt;span class=&quot;string&quot;&gt;&quot;&amp;#123;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;    \&quot;query\&quot; : &amp;#123;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;        \&quot;match\&quot; : &amp;#123;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;            \&quot;last_name\&quot; : \&quot;Smith\&quot;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;        &amp;#125;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;    &amp;#125;\n&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;&amp;#125;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Search build = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Search.Builder(query).addIndex(&lt;span class=&quot;string&quot;&gt;&quot;nanchang&quot;&lt;/span&gt;).addType(&lt;span class=&quot;string&quot;&gt;&quot;student&quot;&lt;/span&gt;).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		SearchResult execute = jestClient.execute(build);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(execute);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="ElasticSearch" scheme="https://LiuHuAshen.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>两数和</title>
    <link href="https://liuhuashen.github.io/2020/05/13/%E4%B8%A4%E6%95%B0%E5%92%8C/"/>
    <id>https://liuhuashen.github.io/2020/05/13/%E4%B8%A4%E6%95%B0%E5%92%8C/</id>
    <published>2020-05-13T02:39:20.000Z</published>
    <updated>2020-05-13T03:33:14.710Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。<br>示例:<br>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><p><strong>我的解决方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>]=i;</span><br><span class="line">                    result[<span class="number">1</span>]=j;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test01 t=<span class="keyword">new</span> Test01();</span><br><span class="line">        <span class="keyword">int</span>[] n=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(t.twoSum(n, <span class="number">3</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;br&gt;示例:&lt;br&gt;给定</summary>
      
    
    
    
    
    <category term="每日算法" scheme="https://LiuHuAshen.github.io/tags/每日算法/"/>
    
  </entry>
  
  <entry>
    <title>代价函数</title>
    <link href="https://liuhuashen.github.io/2020/05/13/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/"/>
    <id>https://liuhuashen.github.io/2020/05/13/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</id>
    <published>2020-05-13T01:05:31.000Z</published>
    <updated>2020-05-13T01:06:53.637Z</updated>
    
    <content type="html"><![CDATA[<p>  在线性回归中我们有一个像这样的训练集，𝑚代表了训练样本的数量，比如 𝑚 = 47。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式： ℎ𝜃(𝑥) = 𝜃0 + 𝜃1𝑥。我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预测的值与训练集中实际值之间的差距（下图中蓝线所指）就是建模误差（modeling error）。<br><img src="https://img-blog.csdnimg.cn/20191106151844646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 我们的目标便是选择出可以使得建模误差的平方和能够最小的模型参数。 即使得代价函数<img src="https://img-blog.csdnimg.cn/20191106151044613.png" alt="在这里插入图片描述">达到最小。</p><p>我们绘制一个等高线图，三个坐标分别为𝜃0和𝜃1 和𝐽(𝜃0,𝜃1)，如下图所示，可以看出在三维空间中存在一个使得𝐽(𝜃0,𝜃1)最小的点。<br><img src="https://img-blog.csdnimg.cn/20191106151420198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>为什么误差平方代价函数？</strong>代价函数也被称作平方误差函数，有时也被称为平方误差代价函数。我们之所以要求出误差的平方和，是因为误差平方代价函数，对于大多数问题，特别是回归问题，都是一个合理的选择。还有其他的代价函数也能很好地发挥作用，但是平方误差代价函数可能是解决回归问题最常用的手段了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  在线性回归中我们有一个像这样的训练集，𝑚代表了训练样本的数量，比如 𝑚 = 47。而我们的假设函数，也就是用来进行预测的函数，是这样的线性函数形式： ℎ𝜃(𝑥) = 𝜃0 + 𝜃1𝑥。我们选择的参数决定了我们得到的直线相对于我们的训练集的准确程度，模型所预</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://LiuHuAshen.github.io/tags/机器学习/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇随笔</title>
    <link href="https://liuhuashen.github.io/2020/01/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94/"/>
    <id>https://liuhuashen.github.io/2020/01/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E9%9A%8F%E7%AC%94/</id>
    <published>2020-01-08T06:44:21.000Z</published>
    <updated>2020-01-08T06:47:15.420Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，这是我博客中的第一篇随笔</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大家好，这是我博客中的第一篇随笔&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://LiuHuAshen.github.io/tags/随笔/"/>
    
  </entry>
  
  <entry>
    <title>scrapy爬虫的一个实例</title>
    <link href="https://liuhuashen.github.io/2019/12/28/scrapy%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/"/>
    <id>https://liuhuashen.github.io/2019/12/28/scrapy%E7%88%AC%E8%99%AB%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B/</id>
    <published>2019-12-28T04:05:39.000Z</published>
    <updated>2019-12-28T04:13:06.368Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一:建立一个Scrapy爬虫工程</strong><br>打开cmd:输人scrapy scrapyproject python123,,如下截图:<br>这里输入的意思是定义一个工程,它的名字叫python123.<br><img src="https://img-blog.csdnimg.cn/20191030195534891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt></p><a id="more"></a><p>此时在d盘中可以看到生成的scrapy的工程<br><img src="https://img-blog.csdnimg.cn/20191030195822965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>介绍上述文件的作用：<br><strong>scrapy.cfg</strong>  这个配置,是将爬虫放在特定的服务器上,并且在服务器配置好相关的操作接口.对于本机使用爬虫,不需要改变部署的配置文件.<br><strong>init.py</strong>  用户不需要编写<br><strong>items.py</strong>  需要继承scrapy库提供的ietms类,对于一般的例子用户不需要编写<br><strong>middlewares.py</strong>  如果用户需要扩展middlewares的功能,则需要编写.<br><strong>pipelines.py</strong>  指的是框架中的pipelines模块<br><strong>settings.py</strong>  指的是Scrapy爬虫的文件,如果需要优化爬虫,则需要设置这个文件对应的配置项.<br><strong>spiders</strong>    是在存放python123demo工程建立的爬虫</p><p><strong>二:在工程中产生一个Scrapy爬虫</strong><br>输入命令：scrapy genspider demo python123.io<br><img src="https://img-blog.csdnimg.cn/20191030200217681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>三、配置产生的spider爬虫</strong><br>在文件当中生成了一个demo.py文件，然后对该文件进行修改，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoSpider(scrapy.Spider):</span><br><span class="line">    name = <span class="string">'demo'</span></span><br><span class="line">    #allowed_domains = ['python123.io']</span><br><span class="line">    start_urls = [<span class="string">'http://python123.io/ws/demo.html'</span>]</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        fname=response.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">with</span> open(fname,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.body)</span><br><span class="line">        self.log(<span class="string">'Save file %s.'</span> %fname)</span><br></pre></td></tr></table></figure><p>1 )是一个面向对象编写的类,这个类叫DemoSpider<br>2 )由于我们的名字叫demo,所以这个类名也叫demospider,名字也可以叫我们任何想叫的名字.<br>3 )这个类必须是继承与scrapy.Spider的子类.<br>4 )这里有个变量叫name,被赋值为demo,说明当前爬虫的名字叫demo.<br>5 )allowed_domains这个是用户提交给命令行的命名.这个爬虫在爬取网站的时候只能爬取这个域名以下的相关链接.<br>6 )start_urls以列表的形式包含一个或多个url就是scrapy框架要爬取的初始页面.<br>7 )def parse是解析页面一个空的方法.<br>8 )pass是处理响应,可以解析从网上爬取的内容,并形成字典类型,同时对网络中爬取的内容发现其中隐含的新的url.</p><p>程序的改进，使用yield生成器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DemoSpider(scrapy.Spider):</span><br><span class="line">    name = <span class="string">'demo'</span></span><br><span class="line">    def start_requests(self):</span><br><span class="line">        urls=[</span><br><span class="line">              <span class="string">'http://python123.io/ws/demo.html'</span></span><br><span class="line">            ]</span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url=url,callback=self.parse)</span><br><span class="line"></span><br><span class="line">    def parse(self, response):</span><br><span class="line">        fname=response.url.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">with</span> open(fname,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.body)</span><br><span class="line">        self.log(<span class="string">'Save file %s.'</span> %fname)</span><br></pre></td></tr></table></figure><p><strong>四、运行爬虫,获取网页</strong><br>在命令行cmd执行这个命令,输入:crapy crawl demo<br><img src="https://img-blog.csdnimg.cn/20191030200823465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时，就爬取成功了，在目录下生成了demo.html文件<br><img src="https://img-blog.csdnimg.cn/20191030200905413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;一:建立一个Scrapy爬虫工程&lt;/strong&gt;&lt;br&gt;打开cmd:输人scrapy scrapyproject python123,,如下截图:&lt;br&gt;这里输入的意思是定义一个工程,它的名字叫python123.&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191030195534891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hCMTU0NTg3NTU=,size_16,color_FFFFFF,t_70&quot; alt&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="scrapy" scheme="https://LiuHuAshen.github.io/tags/scrapy/"/>
    
    <category term="爬虫" scheme="https://LiuHuAshen.github.io/tags/爬虫/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的优化</title>
    <link href="https://liuhuashen.github.io/2019/12/27/MySQL%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>https://liuhuashen.github.io/2019/12/27/MySQL%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2019-12-27T02:38:43.000Z</published>
    <updated>2019-12-28T05:39:55.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="为什么要优化，优化原因"><a href="#为什么要优化，优化原因" class="headerlink" title="为什么要优化，优化原因"></a>为什么要优化，优化原因</h2><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><a id="more"></a><p>#本文摘要</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTMwLzUzNTM1NDE5LmpwZw?x-oss-process=image/format,png" alt></p><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><ul><li>设计数据库时：数据库表、字段的设计，存储引擎</li><li>利用好MySQL自身提供的功能，如索引等</li><li>横向扩展：MySQL集群、负载均衡、读写分离</li><li>SQL语句的优化（收效甚微）</li></ul><h1 id="字段设计"><a href="#字段设计" class="headerlink" title="字段设计"></a>字段设计</h1><blockquote><p>字段类型的选择，设计规范，范式，常见设计案例</p></blockquote><h2 id="原则：尽量使用整型表示字符串"><a href="#原则：尽量使用整型表示字符串" class="headerlink" title="原则：尽量使用整型表示字符串"></a>原则：尽量使用整型表示字符串</h2><h3 id="存储IP"><a href="#存储IP" class="headerlink" title="存储IP"></a>存储IP</h3><p><code>INET_ATON(str)</code>，address to number</p><p><code>INET_NTOA(number)</code>，number to address</p><h3 id="MySQL内部的枚举类型（单选）和集合（多选）类型"><a href="#MySQL内部的枚举类型（单选）和集合（多选）类型" class="headerlink" title="MySQL内部的枚举类型（单选）和集合（多选）类型"></a>MySQL内部的枚举类型（单选）和集合（多选）类型</h3><p>但是因为维护成本较高因此不常使用，使用<strong>关联表</strong>的方式来替代<code>enum</code>    </p><h2 id="原则：定长和非定长数据类型的选择"><a href="#原则：定长和非定长数据类型的选择" class="headerlink" title="原则：定长和非定长数据类型的选择"></a>原则：定长和非定长数据类型的选择</h2><blockquote><p>decimal不会损失精度，存储空间会随数据的增大而增大。double占用固定空间，较大数的存储会损失精度。非定长的还有varchar、text</p></blockquote><h3 id="金额"><a href="#金额" class="headerlink" title="金额"></a>金额</h3><blockquote><p>对数据的精度要求较高，小数的运算和存储存在精度问题（不能将所有小数转换成二进制）</p></blockquote><h3 id="定点数decimal"><a href="#定点数decimal" class="headerlink" title="定点数decimal"></a>定点数decimal</h3><p><code>price decimal(8,2)</code>有2位小数的定点数，定点数支持很大的数（甚至是超过<code>int,bigint</code>存储范围的数）</p><h3 id="小单位大数额避免出现小数"><a href="#小单位大数额避免出现小数" class="headerlink" title="小单位大数额避免出现小数"></a>小单位大数额避免出现小数</h3><p>元-&gt;分</p><h3 id="字符串存储"><a href="#字符串存储" class="headerlink" title="字符串存储"></a>字符串存储</h3><p>定长<code>char</code>，非定长<code>varchar、text</code>（上限65535，其中<code>varchar</code>还会消耗1-3字节记录长度，而<code>text</code>使用额外空间记录长度）</p><h2 id="原则：尽可能选择小的数据类型和指定短的长度"><a href="#原则：尽可能选择小的数据类型和指定短的长度" class="headerlink" title="原则：尽可能选择小的数据类型和指定短的长度"></a>原则：尽可能选择小的数据类型和指定短的长度</h2><h2 id="原则：尽可能使用-not-null"><a href="#原则：尽可能使用-not-null" class="headerlink" title="原则：尽可能使用 not null"></a>原则：尽可能使用 not null</h2><p>非<code>null</code>字段的处理要比<code>null</code>字段的处理高效些！且不需要判断是否为<code>null</code>。</p><p><code>null</code>在MySQL中，不好处理，存储需要额外空间，运算也需要特殊的运算符。如<code>select null = null</code>和<code>select null &lt;&gt; null</code>（<code>&lt;&gt;</code>为不等号）有着同样的结果，只能通过<code>is null</code>和<code>is not null</code>来判断字段是否为<code>null</code>。</p><p>如何存储？MySQL中每条记录都需要额外的存储空间，表示每个字段是否为<code>null</code>。因此通常使用特殊的数据进行占位，比如<code>int not null default 0</code>、<code>string not null default ‘’</code></p><h2 id="原则：字段注释要完整，见名知意"><a href="#原则：字段注释要完整，见名知意" class="headerlink" title="原则：字段注释要完整，见名知意"></a>原则：字段注释要完整，见名知意</h2><h2 id="原则：单表字段不宜过多"><a href="#原则：单表字段不宜过多" class="headerlink" title="原则：单表字段不宜过多"></a>原则：单表字段不宜过多</h2><p>二三十个就极限了</p><h2 id="原则：可以预留字段"><a href="#原则：可以预留字段" class="headerlink" title="原则：可以预留字段"></a>原则：可以预留字段</h2><blockquote><p>在使用以上原则之前首先要满足业务需求</p></blockquote><h1 id="关联表的设计"><a href="#关联表的设计" class="headerlink" title="关联表的设计"></a>关联表的设计</h1><blockquote><p>外键<code>foreign key</code>只能实现一对一或一对多的映射</p></blockquote><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>使用外键</p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>单独新建一张表将多对多拆分成两个一对多</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>如商品的基本信息（<code>item</code>）和商品的详细信息（<code>item_intro</code>），通常使用相同的主键或者增加一个外键字段（<code>item_id</code>）</p><h1 id="范式-Normal-Format"><a href="#范式-Normal-Format" class="headerlink" title="范式 Normal Format"></a>范式 Normal Format</h1><blockquote><p>数据表的设计规范，一套越来越严格的规范体系（如果需要满足N范式，首先要满足N-1范式）。N</p></blockquote><h2 id="第一范式1NF：字段原子性"><a href="#第一范式1NF：字段原子性" class="headerlink" title="第一范式1NF：字段原子性"></a>第一范式1NF：字段原子性</h2><p>字段原子性，字段不可再分割。</p><blockquote><p>关系型数据库，默认满足第一范式</p></blockquote><p>注意比较容易出错的一点，在一对多的设计中使用逗号分隔多个外键，这种方法虽然存储方便，但不利于维护和索引（比如查找带标签<code>java</code>的文章）</p><h2 id="第二范式：消除对主键的部分依赖"><a href="#第二范式：消除对主键的部分依赖" class="headerlink" title="第二范式：消除对主键的部分依赖"></a>第二范式：消除对主键的部分依赖</h2><blockquote><p>即在表中加上一个与业务逻辑无关的字段作为主键</p></blockquote><p>主键：可以唯一标识记录的字段或者字段集合。</p><table><thead><tr><th>course_name</th><th>course_class</th><th>weekday（周几）</th><th>course_teacher</th></tr></thead><tbody><tr><td>MySQL</td><td>教育大楼1525</td><td>周一</td><td>张三</td></tr><tr><td>Java</td><td>教育大楼1521</td><td>周三</td><td>李四</td></tr><tr><td>MySQL</td><td>教育大楼1521</td><td>周五</td><td>张三</td></tr></tbody></table><p>依赖：A字段可以确定B字段，则B字段依赖A字段。比如知道了下一节课是数学课，就能确定任课老师是谁。于是<strong>周几</strong>和<strong>下一节课</strong>和就能构成复合主键，能够确定去哪个教室上课，任课老师是谁等。但我们常常增加一个<code>id</code>作为主键，而消除对主键的部分依赖。</p><p>对主键的部分依赖：某个字段依赖复合主键中的一部分。</p><p>解决方案：新增一个独立字段作为主键。</p><h2 id="第三范式：消除对主键的传递依赖"><a href="#第三范式：消除对主键的传递依赖" class="headerlink" title="第三范式：消除对主键的传递依赖"></a>第三范式：消除对主键的传递依赖</h2><p>传递依赖：B字段依赖于A，C字段又依赖于B。比如上例中，任课老师是谁取决于是什么课，是什么课又取决于主键<code>id</code>。因此需要将此表拆分为两张表日程表和课程表（独立数据独立建表）：</p><table><thead><tr><th>id</th><th>weekday</th><th>course_class</th><th>course_id</th></tr></thead><tbody><tr><td>1001</td><td>周一</td><td>教育大楼1521</td><td>3546</td></tr></tbody></table><table><thead><tr><th>course_id</th><th>course_name</th><th>course_teacher</th></tr></thead><tbody><tr><td>3546</td><td>Java</td><td>张三</td></tr></tbody></table><p>这样就减少了数据的冗余（即使周一至周日每天都有Java课，也只是<code>course_id:3546</code>出现了7次）</p><h1 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h1><blockquote><p>早期问题：如何选择MyISAM和Innodb？</p><p>现在不存在这个问题了，Innodb不断完善，从各个方面赶超MyISAM，也是MySQL默认使用的。</p></blockquote><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p><h2 id="功能差异"><a href="#功能差异" class="headerlink" title="功能差异"></a>功能差异</h2><p><code>show engines</code></p><table><thead><tr><th>Engine</th><th>Support</th><th>Comment</th></tr></thead><tbody><tr><td>InnoDB</td><td>DEFAULT</td><td><strong>Supports transactions, row-level locking, and foreign keys</strong></td></tr><tr><td>MyISAM</td><td>YES</td><td><strong>MyISAM storage engine</strong></td></tr></tbody></table><h2 id="存储差异"><a href="#存储差异" class="headerlink" title="存储差异"></a>存储差异</h2><table><thead><tr><th></th><th>MyISAM</th><th>Innodb</th></tr></thead><tbody><tr><td>文件格式</td><td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td><td>数据和索引是集中存储的，<code>.ibd</code></td></tr><tr><td>文件能否移动</td><td>能，一张表就对应<code>.frm</code>、<code>MYD</code>、<code>MYI</code>3个文件</td><td>否，因为关联的还有<code>data</code>下的其它文件</td></tr><tr><td>记录存储顺序</td><td>按记录插入顺序保存</td><td>按主键大小有序插入</td></tr><tr><td>空间碎片（删除记录并<code>flush table 表名</code>之后，表文件大小不变）</td><td>产生。定时整理：使用命令<code>optimize table 表名</code>实现</td><td>不产生</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr><tr><td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td><td>表级锁定</td><td>行级锁定、表级锁定，锁定力度小并发能力高</td></tr></tbody></table><blockquote><p>锁扩展 </p><p>表级锁（<code>table-level lock</code>）：<code>lock tables &lt;table_name1&gt;,&lt;table_name2&gt;... read/write</code>，<code>unlock tables &lt;table_name1&gt;,&lt;table_name2&gt;...</code>。其中<code>read</code>是共享锁，一旦锁定任何客户端都不可读；<code>write</code>是独占/写锁，只有加锁的客户端可读可写，其他客户端既不可读也不可写。锁定的是一张表或几张表。</p><p>行级锁（<code>row-level lock</code>）：锁定的是一行或几行记录。共享锁：<code>select * from &lt;table_name&gt; where &lt;条件&gt; LOCK IN SHARE MODE;</code>，对查询的记录增加共享锁；<code>select * from &lt;table_name&gt; where &lt;条件&gt; FOR UPDATE;</code>，对查询的记录增加排他锁。这里<strong>值得注意</strong>的是：<code>innodb</code>的行锁，其实是一个子范围锁，依据条件锁定部分范围，而不是就映射到具体的行上，因此还有一个学名：间隙锁。比如<code>select * from stu where id &lt; 20 LOCK IN SHARE MODE</code>会锁定<code>id</code>在<code>20</code>左右以下的范围，你可能无法插入<code>id</code>为<code>18</code>或<code>22</code>的一条新纪录。</p></blockquote><h2 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h2><p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键保证数据完整性。比如OA自动化办公系统。</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><blockquote><p>关键字与数据的映射关系称为索引（==包含关键字和对应的记录在磁盘中的地址==）。关键字是从数据当中提取的用于标识、检索数据的特定内容。</p></blockquote><h2 id="索引检索为什么快？"><a href="#索引检索为什么快？" class="headerlink" title="索引检索为什么快？"></a>索引检索为什么快？</h2><ul><li>关键字相对于数据本身，==数据量小==</li><li>关键字是==有序==的，二分查找可快速确定位置</li></ul><p>图书馆为每本书都加了索引号（类别-楼层-书架）、字典为词语解释按字母顺序编写目录等都用到了索引。</p><h2 id="MySQL中索引类型"><a href="#MySQL中索引类型" class="headerlink" title="MySQL中索引类型"></a>MySQL中索引类型</h2><blockquote><p><strong>普通索引</strong>（<code>key</code>），<strong>唯一索引</strong>（<code>unique key</code>），<strong>主键索引</strong>（<code>primary key</code>），<strong>全文索引</strong>（<code>fulltext key</code>）</p></blockquote><p>三种索引的索引方式是一样的，只不过对索引的关键字有不同的限制：</p><ul><li>普通索引：对关键字没有限制</li><li>唯一索引：要求记录提供的关键字不能重复</li><li>主键索引：要求关键字唯一且不为null</li></ul><h2 id="索引管理语法"><a href="#索引管理语法" class="headerlink" title="索引管理语法"></a>索引管理语法</h2><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p><code>show create table 表名</code>：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzUxNDU3MjQ2LmpwZw?x-oss-process=image/format,png" alt></p><p><code>desc 表名</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2Lzk3MDA1MzM0LmpwZw?x-oss-process=image/format,png" alt></p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="创建表之后建立索引"><a href="#创建表之后建立索引" class="headerlink" title="创建表之后建立索引"></a>创建表之后建立索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> user_index(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span>(<span class="number">16</span>),</span><br><span class="line">id_card <span class="built_in">VARCHAR</span>(<span class="number">18</span>),</span><br><span class="line">information <span class="built_in">text</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更改表结构</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 创建一个first_name和last_name的复合索引，并命名为name</span></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">key</span> <span class="keyword">name</span> (first_name,last_name),</span><br><span class="line"><span class="comment">-- 创建一个id_card的唯一索引，默认以字段名作为索引名</span></span><br><span class="line"><span class="keyword">add</span> <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card),</span><br><span class="line"><span class="comment">-- 鸡肋，全文索引不支持中文</span></span><br><span class="line"><span class="keyword">add</span> FULLTEXT <span class="keyword">KEY</span> (information);</span><br></pre></td></tr></table></figure><p><code>show create table user_index</code>：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2Lzg3NjM3NTQ0LmpwZw?x-oss-process=image/format,png" alt></p><h4 id="创建表时指定索引"><a href="#创建表时指定索引" class="headerlink" title="创建表时指定索引"></a>创建表时指定索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information <span class="built_in">text</span>,</span><br><span class="line"><span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> <span class="keyword">name</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> <span class="keyword">KEY</span> information;</span><br></pre></td></tr></table></figure><p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzIyMzkyMDU0LmpwZw?x-oss-process=image/format,png" alt></p><p>需要取消自增长再行删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line"><span class="keyword">MODIFY</span> <span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line"><span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span></span><br></pre></td></tr></table></figure><p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p><h2 id="执行计划explain"><a href="#执行计划explain" class="headerlink" title="执行计划explain"></a>执行计划explain</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> innodb1 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">first_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">last_name <span class="built_in">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">id_card <span class="built_in">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">information <span class="built_in">text</span>,</span><br><span class="line"><span class="keyword">KEY</span> <span class="keyword">name</span> (first_name, last_name),</span><br><span class="line">FULLTEXT <span class="keyword">KEY</span> (information),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (id_card)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> innodb1 (first_name,last_name,id_card,information) <span class="keyword">values</span> (<span class="string">'张'</span>,<span class="string">'三'</span>,<span class="string">'1001'</span>,<span class="string">'华山派'</span>);</span><br></pre></td></tr></table></figure><p>我们可以通过<code>explain selelct</code>来分析SQL语句执行前的执行计划：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzY2MTY3MTM3LmpwZw?x-oss-process=image/format,png" alt></p><p>由上图可看出此SQL语句是按照主键索引来检索的。</p><p>执行计划是：当执行SQL语句时，首先会分析、优化，形成执行计划，在按照执行计划执行。</p><h2 id="索引使用场景（重点）"><a href="#索引使用场景（重点）" class="headerlink" title="索引使用场景（重点）"></a>索引使用场景（重点）</h2><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzQ0OTIwNzkuanBn?x-oss-process=image/format,png" alt></p><p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="built_in">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex=<span class="string">'男'</span>;</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzMzOTE2ODI1LmpwZw?x-oss-process=image/format,png" alt></p><blockquote><p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p></blockquote><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p><p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><blockquote><p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p></blockquote><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后==只写必要的查询字段==，以增加索引覆盖的几率。</p><p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p><h2 id="语法细节（要点）"><a href="#语法细节（要点）" class="headerlink" title="语法细节（要点）"></a>语法细节（要点）</h2><blockquote><p>在满足索引使用的场景下（<code>where/order by/join on</code>或索引覆盖），索引也不一定被使用</p></blockquote><h3 id="字段要独立出现"><a href="#字段要独立出现" class="headerlink" title="字段要独立出现"></a>字段要独立出现</h3><p>比如下面两条SQL语句在语义上相同，但是第一条会使用主键索引而第二条不会。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">20</span><span class="number">-1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">id</span>+<span class="number">1</span> = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h3 id="like查询，不能以通配符开头"><a href="#like查询，不能以通配符开头" class="headerlink" title="like查询，不能以通配符开头"></a><code>like</code>查询，不能以通配符开头</h3><p>比如搜索标题包含<code>mysql</code>的文章：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">'%mysql%'</span>;</span><br></pre></td></tr></table></figure><p>这种SQL的执行计划用不了索引（<code>like</code>语句匹配表达式以通配符开头），因此只能做全表扫描，效率极低，在实际工程中几乎不被采用。而一般会使用第三方提供的支持中文的全文索引来做。</p><p>但是 <strong>关键字查询</strong> 热搜提醒功能还是可以做的，比如键入<code>mysql</code>之后提醒<code>mysql 教程</code>、<code>mysql 下载</code>、<code>mysql 安装步骤</code>等。用到的语句是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> article <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">'mysql%'</span>;</span><br></pre></td></tr></table></figure><p>这种<code>like</code>是可以利用索引的（当然前提是<code>title</code>字段建立过索引）。</p><h3 id="复合索引只对第一个字段有效"><a href="#复合索引只对第一个字段有效" class="headerlink" title="复合索引只对第一个字段有效"></a>复合索引只对第一个字段有效</h3><p>建立复合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> person <span class="keyword">add</span> <span class="keyword">index</span>(first_name,last_name);</span><br></pre></td></tr></table></figure><p>其原理就是将索引先按照从<code>first_name</code>中提取的关键字排序，如果无法确定先后再按照从<code>last_name</code>提取的关键字排序，也就是说该索引表只是按照记录的<code>first_name</code>字段值有序。</p><p>因此<code>select * from person where first_name = ?</code>是可以利用索引的，而<code>select * from person where last_name = ?</code>无法利用索引。  </p><blockquote><p>那么该复合索引的应用场景是什么？==组合查询==</p></blockquote><p>比如对于<code>select * person from first_name = ? and last_name = ?</code>，复合索引就比对<code>first_name</code>和<code>last_name</code>单独建立索引要高效些。很好理解，复合索引首先二分查找与<code>first_name = ?</code>匹配的记录，再在这些记录中二分查找与<code>last_name</code>匹配的记录，只涉及到一张索引表。而分别单独建立索引则是在<code>first_name</code>索引表中二分找出与<code>first_name = ?</code>匹配的记录，再在<code>last_name</code>索引表中二分找出与<code>last_name = ?</code>的记录，两者取交集。</p><h3 id="or，两边条件都有索引可用"><a href="#or，两边条件都有索引可用" class="headerlink" title="or，两边条件都有索引可用"></a>or，两边条件都有索引可用</h3><blockquote><p>一但有一边无索引可用就会导致整个SQL语句的全表扫描</p></blockquote><h3 id="状态值，不容易使用到索引"><a href="#状态值，不容易使用到索引" class="headerlink" title="状态值，不容易使用到索引"></a>状态值，不容易使用到索引</h3><p>如性别、支付状态等状态值字段往往只有极少的几种取值可能，这种字段即使建立索引，也往往利用不上。这是因为，一个状态值可能匹配大量的记录，这种情况MySQL会认为利用索引比全表扫描的效率低，从而弃用索引。索引是随机访问磁盘，而全表扫描是顺序访问磁盘，这就好比有一栋20层楼的写字楼，楼底下的索引牌上写着某个公司对应不相邻的几层楼，你去公司找人，与其按照索引牌的提示去其中一层楼没找到再下来看索引牌再上楼，不如从1楼挨个往上找到顶楼。</p><h2 id="如何创建索引"><a href="#如何创建索引" class="headerlink" title="如何创建索引"></a>如何创建索引</h2><ul><li>建立基础索引：在<code>where、order by、join</code>字段上建立索引。</li><li>优化，组合索引：基于业务逻辑<ul><li>如果条件经常性出现在一起，那么可以考虑将多字段索引升级为==复合索引==</li><li>如果通过增加个别字段的索引，就可以出现==索引覆盖==，那么可以考虑为该字段建立索引</li><li>查询时，不常用到的索引，应该删除掉</li></ul></li></ul><h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p><p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><p>==实操的难度==：在于前缀截取的长度。</p><p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p><h2 id="索引的存储结构"><a href="#索引的存储结构" class="headerlink" title="索引的存储结构"></a>索引的存储结构</h2><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p>btree（多路平衡查找树）是一种广泛应用于==磁盘上实现索引功能==的一种数据结构，也是大多数数据库索引表的实现。</p><p>以<code>add index(first_name,last_name)</code>为例：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzE0NzI4OTU1LmpwZw?x-oss-process=image/format,png" alt></p><p>BTree的一个node可以存储多个关键字，node的大小取决于计算机的文件系统，因此我们可以通过减小索引字段的长度使结点存储更多的关键字。如果node中的关键字已满，那么可以通过每个关键字之间的子节点指针来拓展索引表，但是不能破坏结构的有序性，比如按照<code>first_name</code>第一有序、<code>last_name</code>第二有序的规则，新添加的<code>韩香</code>就可以插到<code>韩康</code>之后。<code>白起 &lt; 韩飞 &lt; 韩康 &lt; 李世民 &lt; 赵奢 &lt; 李寻欢 &lt; 王语嫣 &lt; 杨不悔</code>。这与二叉搜索树的思想是一样的，只不过二叉搜索树的查找效率是<code>log(2,N)</code>（以2为底N的对数），而BTree的查找效率是<code>log(x,N)</code>（其中x为node的关键字数量，可以达到1000以上）。</p><p>从<code>log(1000+,N)</code>可以看出，少量的磁盘读取即可做到大量数据的遍历，这也是btree的设计目的。</p><h3 id="B-Tree聚簇结构"><a href="#B-Tree聚簇结构" class="headerlink" title="B+Tree聚簇结构"></a>B+Tree聚簇结构</h3><p>聚簇结构（也是在BTree上升级改造的）中，关键字和记录是存放在一起的。</p><p>在MySQL中，仅仅只有<code>Innodb</code>的==主键索引为聚簇结构==，其它的索引包括<code>Innodb</code>的非主键索引都是典型的BTree结构。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>在索引被载入内存时，使用哈希结构来存储。</p><h1 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h1><blockquote><p>缓存<code>select</code>语句的查询结果</p></blockquote><h2 id="在配置文件中开启缓存"><a href="#在配置文件中开启缓存" class="headerlink" title="在配置文件中开启缓存"></a>在配置文件中开启缓存</h2><p>windows上是<code>my.ini</code>，linux上是<code>my.cnf</code></p><p>在<code>[mysqld]</code>段中配置<code>query_cache_type</code>：</p><ul><li>0：不开启</li><li>1：开启，默认缓存所有，需要在SQL语句中增加<code>select sql-no-cache</code>提示来放弃缓存</li><li>2：开启，默认都不缓存，需要在SQL语句中增加<code>select sql-cache</code>来主动缓存（==常用==）</li></ul><p>更改配置后需要重启以使配置生效，重启后可通过<code>show variables like ‘query_cache_type’;</code>来查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'query_cache_type'</span>;</span><br><span class="line">query_cache_typeDEMAND</span><br></pre></td></tr></table></figure><h2 id="在客户端设置缓存大小"><a href="#在客户端设置缓存大小" class="headerlink" title="在客户端设置缓存大小"></a>在客户端设置缓存大小</h2><p>通过配置项<code>query_cache_size</code>来设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'query_cache_size'</span>;</span><br><span class="line">query_cache_size0</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> query_cache_size=<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'query_cache_size'</span>;</span><br><span class="line">query_cache_size67108864</span><br></pre></td></tr></table></figure><h2 id="将查询结果缓存"><a href="#将查询结果缓存" class="headerlink" title="将查询结果缓存"></a>将查询结果缓存</h2><p><code>select sql_cache * from user;</code></p><h2 id="重置缓存"><a href="#重置缓存" class="headerlink" title="重置缓存"></a>重置缓存</h2><p><code>reset query cache;</code></p><h2 id="缓存失效问题（大问题）"><a href="#缓存失效问题（大问题）" class="headerlink" title="缓存失效问题（大问题）"></a>缓存失效问题（大问题）</h2><p>当数据表改动时，基于该数据表的任何缓存都会被删除。（表层面的管理，不是记录层面的管理，因此失效率较高）</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>应用程序，不应该关心<code>query cache</code>的使用情况。可以尝试使用，但不能由<code>query cache</code>决定业务逻辑，因为<code>query cache</code>由DBA来管理。</li><li>缓存是以SQL语句为key存储的，因此即使SQL语句功能相同，但如果多了一个空格或者大小写有差异都会导致匹配不到缓存。</li></ol><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，==保证其单个文件的执行效率==。</p><p>最常见的分区方案是按<code>id</code>分区，如下将<code>id</code>的哈希值对10取模将数据均匀分散到10个<code>.ibd</code>存储文件中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> auto_increment PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">title <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span></span><br><span class="line">)<span class="keyword">PARTITION</span> <span class="keyword">by</span> <span class="keyword">HASH</span>(<span class="keyword">id</span>) <span class="keyword">PARTITIONS</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>查看<code>data</code>目录：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzkyMzExMjQ5LmpwZw?x-oss-process=image/format,png" alt></p><blockquote><p>==服务端的表分区对于客户端是透明的==，客户端还是照常插入数据，但服务端会按照分区算法分散存储数据。</p></blockquote><h2 id="MySQL提供的分区算法"><a href="#MySQL提供的分区算法" class="headerlink" title="MySQL提供的分区算法"></a>MySQL提供的分区算法</h2><blockquote><p>==分区依据的字段必须是主键的一部分==，分区是为了快速定位数据，因此该字段的搜索频次较高应作为强检索字段，否则依照该字段分区毫无意义</p></blockquote><h3 id="hash-field"><a href="#hash-field" class="headerlink" title="hash(field)"></a>hash(field)</h3><p>相同的输入得到相同的输出。输出的结果跟输入是否具有规律无关。==仅适用于整型字段==</p><h3 id="key-field"><a href="#key-field" class="headerlink" title="key(field)"></a>key(field)</h3><p>和<code>hash(field)</code>的性质一样，只不过<code>key</code>是==处理字符串==的，比<code>hash()</code>多了一步从字符串中计算出一个整型在做取模操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article_key(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">title <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,title)<span class="comment">-- 要求分区依据字段必须是主键的一部分</span></span><br><span class="line">)<span class="keyword">PARTITION</span> <span class="keyword">by</span> <span class="keyword">KEY</span>(title) <span class="keyword">PARTITIONS</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="range算法"><a href="#range算法" class="headerlink" title="range算法"></a>range算法</h3><p>是一种==条件分区==算法，按照数据大小范围分区（将数据使用某种条件，分散到不同的分区中）。</p><p>如下，按文章的发布时间将数据按照2018年8月、9月、10月分区存放：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article_range(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">title <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span>,</span><br><span class="line">created_time <span class="built_in">int</span>,<span class="comment">-- 发布时间到1970-1-1的毫秒数</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,created_time)<span class="comment">-- 要求分区依据字段必须是主键的一部分</span></span><br><span class="line">)<span class="keyword">charset</span>=utf8</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(created_time)(</span><br><span class="line"><span class="keyword">PARTITION</span> p201808 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1535731199</span>),<span class="comment">-- select UNIX_TIMESTAMP('2018-8-31 23:59:59')</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201809 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1538323199</span>),<span class="comment">-- 2018-9-30 23:59:59</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201810 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1541001599</span>)<span class="comment">-- 2018-10-31 23:59:59</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2Lzg5MzEyNjkyLmpwZw?x-oss-process=image/format,png" alt></p><p>注意：条件运算符只能使用==less than==，这以为着较小的范围要放在前面，比如上述<code>p201808,p201819,p201810</code>分区的定义顺序依照<code>created_time</code>数值范围从小到大，不能颠倒。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article_range <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'MySQL优化'</span>,<span class="string">'内容示例'</span>,<span class="number">1535731180</span>);</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span>;<span class="comment">-- 使操作立即刷新到磁盘文件</span></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzU0OTEwODc5LmpwZw?x-oss-process=image/format,png" alt></p><p>由于插入的文章的发布时间<code>1535731180</code>小于<code>1535731199</code>（<code>2018-8-31 23:59:59</code>），因此被存储到<code>p201808</code>分区中，这种算法的存储到哪个分区取决于数据状况。</p><h3 id="list算法"><a href="#list算法" class="headerlink" title="list算法"></a>list算法</h3><p>也是一种条件分区，按照列表值分区（<code>in (值列表)</code>）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> article_list(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span> auto_increment,</span><br><span class="line">title <span class="built_in">varchar</span>(<span class="number">64</span>),</span><br><span class="line"><span class="keyword">content</span> <span class="built_in">text</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">TINYINT</span>(<span class="number">1</span>),<span class="comment">-- 文章状态：0-草稿，1-完成但未发布，2-已发布</span></span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,<span class="keyword">status</span>)<span class="comment">-- 要求分区依据字段必须是主键的一部分</span></span><br><span class="line">)<span class="keyword">charset</span>=utf8</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">list</span>(<span class="keyword">status</span>)(</span><br><span class="line"><span class="keyword">PARTITION</span> writing <span class="keyword">values</span> <span class="keyword">in</span>(<span class="number">0</span>,<span class="number">1</span>),<span class="comment">-- 未发布的放在一个分区</span></span><br><span class="line"><span class="keyword">PARTITION</span> published <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">2</span>)<span class="comment">-- 已发布的放在一个分区</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> article_list <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'mysql优化'</span>,<span class="string">'内容示例'</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzU0MjQwODc2LmpwZw?x-oss-process=image/format,png" alt></p><h2 id="分区管理语法"><a href="#分区管理语法" class="headerlink" title="分区管理语法"></a>分区管理语法</h2><h3 id="range-list"><a href="#range-list" class="headerlink" title="range/list"></a>range/list</h3><h4 id="增加分区"><a href="#增加分区" class="headerlink" title="增加分区"></a>增加分区</h4><p>前文中我们尝试使用<code>range</code>对文章按照月份归档，随着时间的增加，我们需要增加一个月份：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> article_range <span class="keyword">add</span> <span class="keyword">partition</span>(</span><br><span class="line"><span class="keyword">partition</span> p201811 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1543593599</span>)<span class="comment">-- select UNIX_TIMESTAMP('2018-11-30 23:59:59')</span></span><br><span class="line"><span class="comment">-- more</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzE3MTYwMDEyLmpwZw?x-oss-process=image/format,png" alt></p><h4 id="删除分区"><a href="#删除分区" class="headerlink" title="删除分区"></a>删除分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> article_range <span class="keyword">drop</span> <span class="keyword">PARTITION</span> p201808</span><br></pre></td></tr></table></figure><p>注意：==删除分区后，分区中原有的数据也会随之删除！==</p><h3 id="key-hash"><a href="#key-hash" class="headerlink" title="key/hash"></a>key/hash</h3><h4 id="新增分区"><a href="#新增分区" class="headerlink" title="新增分区"></a>新增分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> article_key <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI2LzgzMDg5NzQ2LmpwZw?x-oss-process=image/format,png" alt></p><h4 id="销毁分区"><a href="#销毁分区" class="headerlink" title="销毁分区"></a>销毁分区</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> article_key <span class="keyword">coalesce</span> <span class="keyword">partition</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>key/hash</code>分区的管理不会删除数据，但是每一次调整（新增或销毁分区）都会将所有的数据重写分配到新的分区上。==效率极低==，最好在设计阶段就考虑好分区策略。</p><h2 id="分区的使用"><a href="#分区的使用" class="headerlink" title="分区的使用"></a>分区的使用</h2><p>当数据表中的数据量很大时，分区带来的效率提升才会显现出来。</p><p>只有检索字段为分区字段时，分区带来的效率提升才会比较明显。因此，==分区字段的选择很重要==，并且==业务逻辑要尽可能地根据分区字段做相应调整==（尽量使用分区字段作为查询条件）。</p><h1 id="水平分割和垂直分割"><a href="#水平分割和垂直分割" class="headerlink" title="水平分割和垂直分割"></a>水平分割和垂直分割</h1><blockquote><p>水平分割：通过建立结构相同的几张表分别存储数据</p><p>垂直分割：将经常一起使用的字段放在一个单独的表中，分割后的表记录之间是一一对应关系。</p></blockquote><h2 id="分表原因"><a href="#分表原因" class="headerlink" title="分表原因"></a>分表原因</h2><ul><li>为数据库减压</li><li>分区算法局限</li><li>数据库支持不完善（<code>5.1</code>之后<code>mysql</code>才支持分区操作）</li></ul><h2 id="id重复的解决方案"><a href="#id重复的解决方案" class="headerlink" title="id重复的解决方案"></a>id重复的解决方案</h2><ul><li>借用第三方应用如<code>memcache、redis</code>的<code>id</code>自增器</li><li>单独建一张只包含<code>id</code>一个字段的表，每次自增该字段作为数据记录的<code>id</code></li></ul><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><blockquote><p>横向扩展：从根本上（单机的硬件处理能力有限）提升数据库性能 。由此而生的相关技术：==读写分离、负载均衡==</p></blockquote><h2 id="安装和配置主从复制"><a href="#安装和配置主从复制" class="headerlink" title="安装和配置主从复制"></a>安装和配置主从复制</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul><li><code>Red Hat Enterprise Linux Server release 7.0 (Maipo)</code>（虚拟机）</li><li><code>mysql5.7</code>（<a href="https://mirrors.163.com/mysql/Downloads/MySQL-5.7/mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz" target="_blank" rel="noopener">下载地址</a>）</li></ul><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>解压到对外提供的服务的目录（我自己专门创建了一个<code>/export/server</code>来存放）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xzvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz -C /export/server</span><br><span class="line">cd /export/server</span><br><span class="line">mv mysql-5.7.23-linux-glibc2.12-x86_64 mysql</span><br></pre></td></tr></table></figure><p>添加<code>mysql</code>目录的所属组和所属者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -r -g mysql mysql</span><br><span class="line">cd /export/server</span><br><span class="line">chown -R mysql:mysql mysql/</span><br><span class="line">chmod -R 755 mysql/</span><br></pre></td></tr></table></figure><p>创建<code>mysql</code>数据存放目录（其中<code>/export/data</code>是我创建专门用来为各种服务存放数据的目录）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /export/data/mysql</span><br></pre></td></tr></table></figure><p>初始化<code>mysql</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /export/server/mysql</span><br><span class="line">./bin/mysqld --basedir=/export/server/mysql --datadir=/export/data/mysql --user=mysql --pid-file=/export/data/mysql/mysql.pid --initialize</span><br></pre></td></tr></table></figure><blockquote><p>如果成功会显示<code>mysql</code>的<code>root</code>账户的初始密码，记下来以备后续登录。如果报错缺少依赖，则使用<code>yum instally</code>依次安装即可</p></blockquote><p>配置<code>my.cnf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/export/server/mysql</span><br><span class="line">datadir=/export/data/mysql</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">user=mysql</span><br><span class="line">server-id=10 # 服务id，在集群时必须唯一，建议设置为IP的第四段</span><br><span class="line">port=3306</span><br><span class="line"><span class="meta">#</span> Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="meta">#</span> Settings user and group are ignored when systemd is used.</span><br><span class="line"><span class="meta">#</span> If you need to run mysqld under a different user or group,</span><br><span class="line"><span class="meta">#</span> customize your systemd unit file for mariadb according to the</span><br><span class="line"><span class="meta">#</span> instructions in http://fedoraproject.org/wiki/Systemd</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/export/data/mysql/error.log</span><br><span class="line">pid-file=/export/data/mysql/mysql.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> include all files from the config directory</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure><p>将服务添加到开机自动启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /export/server/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure><p>配置环境变量，在<code>/etc/profile</code>中添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> mysql env</span><br><span class="line">MYSQL_HOME=/export/server/mysql</span><br><span class="line">MYSQL_PATH=$MYSQL_HOME/bin</span><br><span class="line">PATH=$PATH:$MYSQL_PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p>使配置即可生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>使用<code>root</code>登录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"><span class="meta">#</span> 这里填写之前初始化服务时提供的密码</span><br></pre></td></tr></table></figure><p>登录上去之后，更改<code>root</code>账户密码（我为了方便将密码改为root），否则操作数据库会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set password=password(&apos;root&apos;);</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>设置服务可被所有远程客户端访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update user set host=&apos;%&apos; where user=&apos;root&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>这样就可以在宿主机使用<code>navicat</code>远程连接虚拟机linux上的mysql了</p></blockquote><h3 id="配置主从节点"><a href="#配置主从节点" class="headerlink" title="配置主从节点"></a>配置主从节点</h3><h4 id="配置master"><a href="#配置master" class="headerlink" title="配置master"></a>配置master</h4><p>以<code>linux</code>（<code>192.168.10.10</code>）上的<code>mysql</code>为<code>master</code>，宿主机（<code>192.168.10.1</code>）上的<code>mysql</code>为<code>slave</code>配置主从复制。</p><p>修改<code>master</code>的<code>my.cnf</code>如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=/export/server/mysql</span><br><span class="line">datadir=/export/data/mysql</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">user=mysql</span><br><span class="line">server-id=10</span><br><span class="line">port=3306</span><br><span class="line"><span class="meta">#</span> Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links=0</span><br><span class="line"><span class="meta">#</span> Settings user and group are ignored when systemd is used.</span><br><span class="line"><span class="meta">#</span> If you need to run mysqld under a different user or group,</span><br><span class="line"><span class="meta">#</span> customize your systemd unit file for mariadb according to the</span><br><span class="line"><span class="meta">#</span> instructions in http://fedoraproject.org/wiki/Systemd</span><br><span class="line"></span><br><span class="line">log-bin=mysql-bin# 开启二进制日志</span><br><span class="line">expire-logs-days=7  # 设置日志过期时间，避免占满磁盘</span><br><span class="line">binlog-ignore-db=mysql# 不使用主从复制的数据库</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line">binlog-ignore-db=performation_schema</span><br><span class="line">binlog-ignore-db=sys</span><br><span class="line">binlog-do-db=test#使用主从复制的数据库</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/export/data/mysql/error.log</span><br><span class="line">pid-file=/export/data/mysql/mysql.pid</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> include all files from the config directory</span><br><span class="line"><span class="meta">#</span></span><br><span class="line">!includedir /etc/my.cnf.d</span><br></pre></td></tr></table></figure><p>重启<code>master</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><p>登录<code>master</code>查看配置是否生效（<code>ON</code>即为开启，默认为<code>OFF</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_bin&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br></pre></td></tr></table></figure><p>在<code>master</code>的数据库中建立备份账号：<code>backup</code>为用户名，<code>%</code>表示任何远程地址，用户<code>back</code>可以使用密码<code>1234</code>通过任何远程客户端连接<code>master</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant replication slave on *.* to &apos;backup&apos;@&apos;%&apos; identified by &apos;1234&apos;</span><br></pre></td></tr></table></figure><p>查看<code>user</code>表可以看到我们刚创建的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use mysql</span><br><span class="line">mysql&gt; select user,authentication_string,host from user;</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------+-----------+</span></span><br><span class="line">| user          | authentication_string                     | host      |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------+-----------+</span></span><br><span class="line">| root          | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | %         |</span><br><span class="line">| mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost |</span><br><span class="line">| mysql.sys     | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost |</span><br><span class="line">| <span class="keyword">backup</span>        | *A4B6157319038724E3560894F7F932C8886EBFCF | %         |</span><br><span class="line">+<span class="comment">---------------+-------------------------------------------+-----------+</span></span><br></pre></td></tr></table></figure><p>新建<code>test</code>数据库，创建一个<code>article</code>表以备后续测试</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`article`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">text</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>重启服务并刷新数据库状态到存储文件中（<code>with read lock</code>表示在此过程中，客户端只能读数据，以便获得一个一致性的快照）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zhenganwen ~]# service mysqld restart</span><br><span class="line">Shutting down MySQL.... SUCCESS! </span><br><span class="line">Starting MySQL. SUCCESS! </span><br><span class="line">[root@zhenganwen mysql]# mysql -uroot -proot</span><br><span class="line"><span class="meta">mysql&gt;</span> flush tables with read lock;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看<code>master</code>上当前的二进制日志和偏移量（记一下其中的<code>File</code>和<code>Position</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             File: mysql-bin.000002</span><br><span class="line">         Position: 154</span><br><span class="line">     Binlog_Do_DB: test</span><br><span class="line"> Binlog_Ignore_DB: mysql,information_schema,performation_schema,sys</span><br><span class="line">Executed_Gtid_Set: </span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI5LzkwNDg1MTQwLmpwZw?x-oss-process=image/format,png" alt></p><p><code>File</code>表示实现复制功能的日志，即上图中的<code>Binary log</code>；<code>Position</code>则表示<code>Binary log</code>日志文件的偏移量之后的都会同步到<code>slave</code>中，那么在偏移量之前的则需要我们手动导入。</p><p>主服务器上面的任何修改都会保存在二进制日志Binary log里面，从服务器上面启动一个I/O thread（实际上就是一个主服务器的客户端进程），连接到主服务器上面请求读取二进制日志，然后把读取到的二进制日志写到本地的一个Realy log里面。从服务器上面开启一个SQL thread定时检查Realy log，如果发现有更改立即把更改的内容在本机上面执行一遍。</p><p>如果一主多从的话，这时主库既要负责写又要负责为几个从库提供二进制日志。此时可以稍做调整，将二进制日志只给某一从，这一从再开启二进制日志并将自己的二进制日志再发给其它从。或者是干脆这个从不记录只负责将二进制日志转发给其它从，这样架构起来性能可能要好得多，而且数据之间的延时应该也稍微要好一些</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI5LzM3MTYyNTQ3LmpwZw?x-oss-process=image/format,png" alt></p><p>手动导入，从<code>master</code>中导出数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot -hlocalhost test &gt; /export/data/test.sql</span><br></pre></td></tr></table></figure><p>将<code>test.sql</code>中的内容在<code>slave</code>上执行一遍。</p><h4 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h4><p>修改<code>slave</code>的<code>my.ini</code>文件中的<code>[mysqld]</code>部分</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">log-bin</span>=mysql</span><br><span class="line"><span class="attr">server-id</span>=<span class="number">1</span> <span class="comment">#192.168.10.1</span></span><br></pre></td></tr></table></figure><p>保存修改后重启<code>slave</code>，<code>WIN+R</code>-&gt;<code>services.msc</code>-&gt;<code>MySQL5.7</code>-&gt;重新启动</p><p>登录<code>slave</code>检查<code>log_bin</code>是否以被开启：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">VARIABLES</span> <span class="keyword">like</span> <span class="string">'log_bin'</span>;</span><br></pre></td></tr></table></figure><p>配置与<code>master</code>的同步复制：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>; </span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span></span><br><span class="line">    master_host=<span class="string">'192.168.10.10'</span>,<span class="comment">-- master的IP</span></span><br><span class="line">    master_user=<span class="string">'backup'</span>,    <span class="comment">-- 之前在master上创建的用户</span></span><br><span class="line">    master_password=<span class="string">'1234'</span>,</span><br><span class="line">    master_log_file=<span class="string">'mysql-bin.000002'</span>, <span class="comment">-- master上 show master status \G 提供的信息</span></span><br><span class="line">    master_log_pos=<span class="number">154</span>;</span><br></pre></td></tr></table></figure><p>启用<code>slave</code>节点并查看状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.10.10</span><br><span class="line">                  Master_User: <span class="keyword">backup</span></span><br><span class="line">                  Master_Port: <span class="number">3306</span></span><br><span class="line">                Connect_Retry: <span class="number">60</span></span><br><span class="line">              Master_Log_File: mysql-<span class="keyword">bin</span><span class="number">.000002</span></span><br><span class="line">          Read_Master_Log_Pos: <span class="number">154</span></span><br><span class="line">               Relay_Log_File: DESKTOP-KUBSPE0-relay-<span class="keyword">bin</span><span class="number">.000002</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">320</span></span><br><span class="line">        Relay_Master_Log_File: mysql-<span class="keyword">bin</span><span class="number">.000002</span></span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB:</span><br><span class="line">          Replicate_Ignore_DB:</span><br><span class="line">           Replicate_Do_Table:</span><br><span class="line">       Replicate_Ignore_Table:</span><br><span class="line">      Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">                   Last_Errno: <span class="number">0</span></span><br><span class="line">                   Last_Error:</span><br><span class="line">                 Skip_Counter: <span class="number">0</span></span><br><span class="line">          Exec_Master_Log_Pos: <span class="number">154</span></span><br><span class="line">              Relay_Log_Space: <span class="number">537</span></span><br><span class="line">              Until_Condition: <span class="keyword">None</span></span><br><span class="line">               Until_Log_File:</span><br><span class="line">                Until_Log_Pos: <span class="number">0</span></span><br><span class="line">           Master_SSL_Allowed: <span class="keyword">No</span></span><br><span class="line">           Master_SSL_CA_File:</span><br><span class="line">           Master_SSL_CA_Path:</span><br><span class="line">              Master_SSL_Cert:</span><br><span class="line">            Master_SSL_Cipher:</span><br><span class="line">               Master_SSL_Key:</span><br><span class="line">        Seconds_Behind_Master: <span class="number">0</span></span><br><span class="line">Master_SSL_Verify_Server_Cert: <span class="keyword">No</span></span><br><span class="line">                Last_IO_Errno: <span class="number">0</span></span><br><span class="line">                Last_IO_Error:</span><br><span class="line">               Last_SQL_Errno: <span class="number">0</span></span><br><span class="line">               Last_SQL_Error:</span><br><span class="line">  Replicate_Ignore_Server_Ids:</span><br><span class="line">             Master_Server_Id: <span class="number">10</span></span><br><span class="line">                  Master_UUID: f68774b7<span class="number">-0</span>b28<span class="number">-11e9</span>-a925<span class="number">-000</span>c290abe05</span><br><span class="line">             Master_Info_File: C:\ProgramData\MySQL\MySQL <span class="keyword">Server</span> <span class="number">5.7</span>\<span class="keyword">Data</span>\master.info</span><br><span class="line">                    SQL_Delay: <span class="number">0</span></span><br><span class="line">          SQL_Remaining_Delay: <span class="literal">NULL</span></span><br><span class="line">      Slave_SQL_Running_State: <span class="keyword">Slave</span> has <span class="keyword">read</span> <span class="keyword">all</span> relay <span class="keyword">log</span>; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind:</span><br><span class="line">      Last_IO_Error_Timestamp:</span><br><span class="line">     Last_SQL_Error_Timestamp:</span><br><span class="line">               Master_SSL_Crl:</span><br><span class="line">           Master_SSL_Crlpath:</span><br><span class="line">           Retrieved_Gtid_Set:</span><br><span class="line">            Executed_Gtid_Set:</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">         Replicate_Rewrite_DB:</span><br><span class="line">                 Channel_Name:</span><br><span class="line">           Master_TLS_Version:</span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>注意查看第4、14、15三行，若与我一致，表示<code>slave</code>配置成功</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>关闭<code>master</code>的读取锁定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; unlock tables;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>向<code>master</code>中插入一条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test</span><br><span class="line">mysql&gt; insert into article (title,content) values ('mysql master and slave','record the cluster building succeed!:)');</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看<code>slave</code>是否自动同步了数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into article (title,content) values ('mysql master and slave','record the cluster building succeed!:)');</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>至此，主从复制的配置成功！：)</p><p><a href="https://blog.csdn.net/xlgen157387/article/details/52452394" target="_blank" rel="noopener">使用mysqlreplicate命令快速搭建 Mysql 主从复制</a></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p><h3 id="方案一、定义两种连接"><a href="#方案一、定义两种连接" class="headerlink" title="方案一、定义两种连接"></a>方案一、定义两种连接</h3><p>就像我们在学JDBC时定义的<code>DataBase</code>一样，我们可以抽取出<code>ReadDataBase,WriteDataBase implements DataBase</code>，但是这种方式无法利用优秀的线程池技术如<code>DruidDataSource</code>帮我们管理连接，也无法利用<code>Spring AOP</code>让连接对<code>DAO</code>层透明。</p><h3 id="方案二、使用Spring-AOP"><a href="#方案二、使用Spring-AOP" class="headerlink" title="方案二、使用Spring  AOP"></a>方案二、使用Spring  AOP</h3><p>如果能够使用<code>Spring AOP</code>解决数据源切换的问题，那么就可以和<code>Mybatis</code>、<code>Druid</code>整合到一起了。</p><p>我们在整合<code>Spring1</code>和<code>Mybatis</code>时，我们只需写DAO接口和对应的<code>SQL</code>语句，那么DAO实例是由谁创建的呢？实际上就是<code>Spring</code>帮我们创建的，它通过我们注入的数据源，帮我们完成从中获取数据库连接、使用连接执行 <code>SQL</code> 语句的过程以及最后归还连接给数据源的过程。</p><p>如果我们能在调用DAO接口时根据接口方法命名规范（增<code>addXXX/createXXX</code>、删<code>deleteXX/removeXXX</code>、改<code>updateXXXX</code>、查<code>selectXX/findXXX/getXX/queryXXX</code>）动态地选择数据源（读数据源对应连接<code>master</code>而写数据源对应连接<code>slave</code>），那么就可以做到读写分离了。</p><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL3phbndlbmJsb2cub3NzLWNuLWJlaWppbmcuYWxpeXVuY3MuY29tLzE4LTEyLTI5LzcxNzQ3MTM3LmpwZw?x-oss-process=image/format,png" alt></p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>其中，为了方便访问数据库引入了<code>mybatis</code>和<code>druid</code>，实现数据源动态切换主要依赖<code>spring-aop</code>和<code>spring-aspects</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h4><p>其中<code>RoutingDataSourceImpl</code>是实现动态切换功能的核心类，稍后介绍。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"top.zhenganwen.mysqloptimize"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"slaveDataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;master.db.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;master.db.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;master.db.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"masterDataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;slave.db.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;slave.db.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;slave.db.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceRouting"</span> <span class="attr">class</span>=<span class="string">"top.zhenganwen.mysqloptimize.dataSource.RoutingDataSourceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultTargetDataSource"</span> <span class="attr">ref</span>=<span class="string">"masterDataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetDataSources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value-type</span>=<span class="string">"javax.sql.DataSource"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"read"</span> <span class="attr">value-ref</span>=<span class="string">"slaveDataSource"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"write"</span> <span class="attr">value-ref</span>=<span class="string">"masterDataSource"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"methodType"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value-type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"read"</span> <span class="attr">value</span>=<span class="string">"query,find,select,get,load,"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"write"</span> <span class="attr">value</span>=<span class="string">"update,add,create,delete,remove,modify"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSourceRouting"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"top.zhenganwen.mysqloptimize.mapper"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dp.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">master.db.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">master.db.username=root</span><br><span class="line">master.db.password=root</span><br><span class="line"></span><br><span class="line">slave.db.url=jdbc:mysql://192.168.10.10:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC</span><br><span class="line">slave.db.username=root</span><br><span class="line">slave.db.password=root</span><br><span class="line"></span><br><span class="line">db.driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p><code>mybatis-config.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"top.zhenganwen.mysqloptimize.entity.Article"</span> <span class="attr">alias</span>=<span class="string">"Article"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mapper接口和配置文件"><a href="#mapper接口和配置文件" class="headerlink" title="mapper接口和配置文件"></a>mapper接口和配置文件</h4><p><code>ArticleMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="keyword">import</span> top.zhenganwen.mysqloptimize.entity.Article;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Article article)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArticleMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"top.zhenganwen.mysqloptimize.mapper.ArticleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAll"</span> <span class="attr">resultType</span>=<span class="string">"Article"</span>&gt;</span></span><br><span class="line">        select * from article</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"add"</span> <span class="attr">parameterType</span>=<span class="string">"Article"</span>&gt;</span></span><br><span class="line">        insert into article (title,content) values (#&#123;title&#125;,#&#123;content&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete from article where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><h5 id="RoutingDataSourceImpl"><a href="#RoutingDataSourceImpl" class="headerlink" title="RoutingDataSourceImpl"></a>RoutingDataSourceImpl</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RoutingDataSourceImpl class</span></span><br><span class="line"><span class="comment"> * 数据源路由</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhenganwen, blog:zhenganwen.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingDataSourceImpl</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key为read或write</span></span><br><span class="line"><span class="comment">     * value为DAO方法的前缀</span></span><br><span class="line"><span class="comment">     * 什么前缀开头的方法使用读数据员，什么开头的方法使用写数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; METHOD_TYPE_MAP = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由我们指定数据源的id，由Spring切换数据源</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"数据源为："</span>+DataSourceHandler.getDataSource());</span><br><span class="line">        <span class="keyword">return</span> DataSourceHandler.getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodType</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String type : map.keySet()) &#123;</span><br><span class="line">            String methodPrefixList = map.get(type);</span><br><span class="line">            <span class="keyword">if</span> (methodPrefixList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                METHOD_TYPE_MAP.put(type, Arrays.asList(methodPrefixList.split(<span class="string">","</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的主要功能是，本来我们只配置一个数据源，因此<code>Spring</code>动态代理DAO接口时直接使用该数据源，现在我们有了读、写两个数据源，我们需要加入一些自己的逻辑来告诉调用哪个接口使用哪个数据源（读数据的接口使用<code>slave</code>，写数据的接口使用<code>master</code>。这个告诉<code>Spring</code>该使用哪个数据源的类就是<code>AbstractRoutingDataSource</code>，必须重写的方法<code>determineCurrentLookupKey</code>返回数据源的标识，结合<code>spring</code>配置文件（下段代码的5，6两行）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceRouting"</span> <span class="attr">class</span>=<span class="string">"top.zhenganwen.mysqloptimize.dataSource.RoutingDataSourceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultTargetDataSource"</span> <span class="attr">ref</span>=<span class="string">"masterDataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetDataSources"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value-type</span>=<span class="string">"javax.sql.DataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"read"</span> <span class="attr">value-ref</span>=<span class="string">"slaveDataSource"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"write"</span> <span class="attr">value-ref</span>=<span class="string">"masterDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"methodType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span> <span class="attr">key-type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value-type</span>=<span class="string">"java.lang.String"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"read"</span> <span class="attr">value</span>=<span class="string">"query,find,select,get,load,"</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"write"</span> <span class="attr">value</span>=<span class="string">"update,add,create,delete,remove,modify"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果<code>determineCurrentLookupKey</code>返回<code>read</code>那么使用<code>slaveDataSource</code>，如果返回<code>write</code>就使用<code>masterDataSource</code>。</p><h5 id="DataSourceHandler"><a href="#DataSourceHandler" class="headerlink" title="DataSourceHandler"></a>DataSourceHandler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.dataSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DataSourceHandler class</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 将数据源与线程绑定，需要时根据线程获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhenganwen, blog:zhenganwen.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定的是read或write，表示使用读或写数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"设置了数据源类型"</span>);</span><br><span class="line">        holder.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"获取了数据源类型"</span>);</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="DataSourceAspect"><a href="#DataSourceAspect" class="headerlink" title="DataSourceAspect"></a>DataSourceAspect</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> top.zhenganwen.mysqloptimize.dataSource.RoutingDataSourceImpl.METHOD_TYPE_MAP;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DataSourceAspect class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 配置切面，根据方法前缀设置读、写数据源</span></span><br><span class="line"><span class="comment"> * 项目启动时会加载该bean，并按照配置的切面（哪些切入点、如何增强）确定动态代理逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhenganwen,blog:zhenganwen.top</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//声明这是一个切面，这样Spring才会做相应的配置，否则只会当做简单的bean注入</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置切入点：DAO包下的所有类的所有方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* top.zhenganwen.mysqloptimize.mapper.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置前置增强，对象是aspect()方法上配置的切入点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"aspect()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint point)</span> </span>&#123;</span><br><span class="line">        String className = point.getTarget().getClass().getName();</span><br><span class="line">        String invokedMethod = point.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"对 "</span>+className+<span class="string">"$"</span>+invokedMethod+<span class="string">" 做了前置增强，确定了要使用的数据源类型"</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; dataSourceType = METHOD_TYPE_MAP.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String type : dataSourceType) &#123;</span><br><span class="line">            List&lt;String&gt; prefixList = METHOD_TYPE_MAP.get(type);</span><br><span class="line">            <span class="keyword">for</span> (String prefix : prefixList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (invokedMethod.startsWith(prefix)) &#123;</span><br><span class="line">                    DataSourceHandler.setDataSource(type);</span><br><span class="line">                    System.out.println(<span class="string">"数据源为："</span>+type);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试读写分离"><a href="#测试读写分离" class="headerlink" title="测试读写分离"></a>测试读写分离</h4><blockquote><p>如何测试读是从<code>slave</code>中读的呢？可以将写后复制到<code>slave</code>中的数据更改，再读该数据就知道是从<code>slave</code>中读了。==注意==，一但对<code>slave</code>做了写操作就要重新手动将<code>slave</code>与<code>master</code>同步一下，否则主从复制就会失效。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.zhenganwen.mysqloptimize.dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> top.zhenganwen.mysqloptimize.entity.Article;</span><br><span class="line"><span class="keyword">import</span> top.zhenganwen.mysqloptimize.mapper.ArticleMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">locations</span> </span>= <span class="string">"classpath:spring-mybatis.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingDataSourceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ArticleMapper articleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(articleMapper.findAll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article(<span class="number">0</span>, <span class="string">"我是新插入的文章"</span>, <span class="string">"测试是否能够写到master并且复制到slave中"</span>);</span><br><span class="line">        articleMapper.add(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        articleMapper.delete(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul><li>轮询</li><li>加权轮询：按照处理能力来加权</li><li>负载分配：依据当前的空闲状态（但是测试每个节点的内存使用率、CPU利用率等，再做比较选出最闲的那个，效率太低）</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>在服务器架构时，为了保证服务器7x24不宕机在线状态，需要为每台单点服务器（由一台服务器提供服务的服务器，如写服务器、数据库中间件）提供冗余机。</p><p>对于写服务器来说，需要提供一台同样的写-冗余服务器，当写服务器健康时（写-冗余通过心跳检测），写-冗余作为一个从机的角色复制写服务器的内容与其做一个同步；当写服务器宕机时，写-冗余服务器便顶上来作为写服务器继续提供服务。对外界来说这个处理过程是透明的，即外界仅通过一个IP访问服务。</p><h1 id="典型SQL"><a href="#典型SQL" class="headerlink" title="典型SQL"></a>典型SQL</h1><h2 id="线上DDL"><a href="#线上DDL" class="headerlink" title="线上DDL"></a>线上DDL</h2><p>DDL(Database Definition Language)是指数据库表结构的定义（<code>create table</code>）和维护（<code>alter table</code>）的语言。在线上执行DDL，在低于<code>MySQL5.6</code>版本时会导致全表被独占锁定，此时表处于维护、不可操作状态，这会导致该期间对该表的所有访问无法响应。但是在<code>MySQL5.6</code>之后，支持<code>Online DDL</code>，大大缩短了锁定时间。</p><p>优化技巧是采用的维护表结构的DDL（比如增加一列，或者增加一个索引），是==copy==策略。思路：创建一个满足新结构的新表，将旧表数据==逐条==导入（复制）到新表中，以保证==一次性锁定的内容少==（锁定的是正在导入的数据），同时旧表上可以执行其他任务。导入的过程中，将对旧表的所有操作以日志的形式记录下来，导入完毕后，将更新日志在新表上再执行一遍（确保一致性）。最后，新表替换旧表（在应用程序中完成，或者是数据库的rename，视图完成）。</p><p>但随着MySQL的升级，这个问题几乎淡化了。</p><h2 id="数据库导入语句"><a href="#数据库导入语句" class="headerlink" title="数据库导入语句"></a>数据库导入语句</h2><p>在恢复数据时，可能会导入大量的数据。此时为了快速导入，需要掌握一些技巧：</p><ol><li>导入时==先禁用索引和约束==：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">table</span>-<span class="keyword">name</span> <span class="keyword">disable</span> <span class="keyword">keys</span></span><br></pre></td></tr></table></figure><p>待数据导入完成之后，再开启索引和约束，一次性创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">table</span>-<span class="keyword">name</span> <span class="keyword">enable</span> <span class="keyword">keys</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数据库如果使用的引擎是<code>Innodb</code>，那么它==默认会给每条写指令加上事务==（这也会消耗一定的时间），因此建议先手动开启事务，再执行一定量的批量导入，最后手动提交事务。</li><li>如果批量导入的SQL指令格式相同只是数据不同，那么你应该先<code>prepare</code>==预编译==一下，这样也能节省很多重复编译的时间。</li></ol><h2 id="limit-offset-rows"><a href="#limit-offset-rows" class="headerlink" title="limit offset,rows"></a>limit offset,rows</h2><p>尽量保证不要出现大的<code>offset</code>，比如<code>limit 10000,10</code>相当于对已查询出来的行数弃掉前<code>10000</code>行后再取<code>10</code>行，完全可以加一些条件过滤一下（完成筛选），而不应该使用<code>limit</code>跳过已查询到的数据。这是一个==<code>offset</code>做无用功==的问题。对应实际工程中，要避免出现大页码的情况，尽量引导用户做条件过滤。</p><h2 id="select-要少用"><a href="#select-要少用" class="headerlink" title="select * 要少用"></a>select * 要少用</h2><p>即尽量选择自己需要的字段<code>select</code>，但这个影响不是很大，因为网络传输多了几十上百字节也没多少延时，并且现在流行的ORM框架都是用的<code>select *</code>，只是我们在设计表的时候注意将大数据量的字段分离，比如商品详情可以单独抽离出一张商品详情表，这样在查看商品简略页面时的加载速度就不会有影响了。</p><h2 id="order-by-rand-不要用"><a href="#order-by-rand-不要用" class="headerlink" title="order by rand()不要用"></a>order by rand()不要用</h2><p>它的逻辑就是随机排序（为每条数据生成一个随机数，然后根据随机数大小进行排序）。如<code>select * from student order by rand() limit 5</code>的执行效率就很低，因为它为表中的每条数据都生成随机数并进行排序，而我们只要前5条。</p><p>解决思路：在应用程序中，将随机的主键生成好，去数据库中利用主键检索。</p><h2 id="单表和多表查询"><a href="#单表和多表查询" class="headerlink" title="单表和多表查询"></a>单表和多表查询</h2><p>多表查询：<code>join</code>、子查询都是涉及到多表的查询。如果你使用<code>explain</code>分析执行计划你会发现多表查询也是一个表一个表的处理，最后合并结果。因此可以说单表查询将计算压力放在了应用程序上，而多表查询将计算压力放在了数据库上。</p><p>现在有ORM框架帮我们解决了单表查询带来的对象映射问题（查询单表时，如果发现有外键自动再去查询关联表，是一个表一个表查的）。</p><h2 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h2><p>在<code>MyISAM</code>存储引擎中，会自动记录表的行数，因此使用<code>count(*)</code>能够快速返回。而<code>Innodb</code>内部没有这样一个计数器，需要我们手动统计记录数量，解决思路就是单独使用一张表：</p><table><thead><tr><th>id</th><th>table</th><th>count</th></tr></thead><tbody><tr><td>1</td><td>student</td><td>100</td></tr></tbody></table><h2 id="limit-1"><a href="#limit-1" class="headerlink" title="limit 1"></a>limit 1</h2><p>如果可以确定仅仅检索一条，建议加上<code>limit 1</code>，其实ORM框架帮我们做到了这一点（查询单条的操作都会自动加上<code>limit 1</code>）。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><blockquote><p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p></blockquote><h2 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h2><p>配置项：<code>slow_query_log</code></p><p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p><h2 id="设置临界时间"><a href="#设置临界时间" class="headerlink" title="设置临界时间"></a>设置临界时间</h2><p>配置项：<code>long_query_time</code></p><p>查看：<code>show VARIABLES like &#39;long_query_time&#39;</code>，单位秒</p><p>设置：<code>set long_query_time=0.5</code></p><p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><p>一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p><h1 id="profile信息"><a href="#profile信息" class="headerlink" title="profile信息"></a>profile信息</h1><p>配置项：<code>profiling</code></p><h2 id="开启profile"><a href="#开启profile" class="headerlink" title="开启profile"></a>开启profile</h2><p><code>set profiling=on</code></p><p>开启后，所有的SQL执行的详细信息都会被自动记录下来</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'profiling';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| profiling     | OFF   |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> profiling=<span class="keyword">on</span>;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="查看profile信息"><a href="#查看profile信息" class="headerlink" title="查看profile信息"></a>查看profile信息</h2><p><code>show profiles</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'profiling';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| profiling     | ON    |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> article <span class="keyword">values</span> (<span class="literal">null</span>,<span class="string">'test profile'</span>,<span class="string">':)'</span>);</span><br><span class="line">Query OK, 1 row affected (0.15 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                 |</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------+</span></span><br><span class="line">|        1 | 0.00086150 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'profiling'</span>                       |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.15027550</span> | <span class="keyword">insert</span> <span class="keyword">into</span> article <span class="keyword">values</span> (<span class="literal">null</span>,<span class="string">'test profile'</span>,<span class="string">':)'</span>) |</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><h2 id="通过Query-ID查看某条SQL所有详细步骤的时间"><a href="#通过Query-ID查看某条SQL所有详细步骤的时间" class="headerlink" title="通过Query_ID查看某条SQL所有详细步骤的时间"></a>通过Query_ID查看某条SQL所有详细步骤的时间</h2><p><code>show profile for query Query_ID</code></p><p>上面<code>show profiles</code>的结果中，每个SQL有一个<code>Query_ID</code>，可以通过它查看执行该SQL经过了哪些步骤，各消耗了多场时间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="典型的服务器配置"><a href="#典型的服务器配置" class="headerlink" title="典型的服务器配置"></a>典型的服务器配置</h1><blockquote><p>以下的配置全都取决于实际的运行环境</p></blockquote><ul><li><p><code>max_connections</code>，最大客户端连接数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'max_connections';</span><br><span class="line">+<span class="comment">-----------------+-------+</span></span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+<span class="comment">-----------------+-------+</span></span><br><span class="line">| max_connections | 151   |</span><br><span class="line">+<span class="comment">-----------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p><code>table_open_cache</code>，表文件句柄缓存（表数据是存储在磁盘上的，缓存磁盘文件的句柄方便打开文件读取数据）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'table_open_cache';</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| table_open_cache | 2000  |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br></pre></td></tr></table></figure></li><li><p><code>key_buffer_size</code>，索引缓存大小（将从磁盘上读取的索引缓存到内存，可以设置大一些，有利于快速检索）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'key_buffer_size';</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br><span class="line">| Variable_name   | Value   |</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br><span class="line">| key_buffer_size | 8388608 |</span><br><span class="line">+<span class="comment">-----------------+---------+</span></span><br></pre></td></tr></table></figure></li><li><p><code>innodb_buffer_pool_size</code>，<code>Innodb</code>存储引擎缓存池大小（对于<code>Innodb</code>来说最重要的一个配置，如果所有的表用的都是<code>Innodb</code>，那么甚至建议将该值设置到物理内存的80%，<code>Innodb</code>的很多性能提升如索引都是依靠这个）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'innodb_buffer_pool_size';</span><br><span class="line">+<span class="comment">-------------------------+---------+</span></span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+<span class="comment">-------------------------+---------+</span></span><br><span class="line">| innodb_buffer_pool_size | 8388608 |</span><br><span class="line">+<span class="comment">-------------------------+---------+</span></span><br></pre></td></tr></table></figure></li><li><p><code>innodb_file_per_table</code>（<code>innodb</code>中，表数据存放在<code>.ibd</code>文件中，如果将该配置项设置为<code>ON</code>，那么一个表对应一个<code>ibd</code>文件，否则所有<code>innodb</code>共享表空间）</p></li></ul><h1 id="压测工具mysqlslap"><a href="#压测工具mysqlslap" class="headerlink" title="压测工具mysqlslap"></a>压测工具mysqlslap</h1><p>安装MySQL时附带了一个压力测试工具<code>mysqlslap</code>（位于<code>bin</code>目录下）</p><h2 id="自动生成sql测试"><a href="#自动生成sql测试" class="headerlink" title="自动生成sql测试"></a>自动生成sql测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 1.219 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 1.219 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 1.219 seconds</span><br><span class="line">        Number of clients running queries: 1</span><br><span class="line">        Average number of queries per client: 0</span><br></pre></td></tr></table></figure><h2 id="并发测试"><a href="#并发测试" class="headerlink" title="并发测试"></a>并发测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=100 -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 3.578 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 3.578 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 3.578 seconds</span><br><span class="line">        Number of clients running queries: 100</span><br><span class="line">        Average number of queries per client: 0</span><br><span class="line">        </span><br><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 5.718 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 5.718 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 5.718 seconds</span><br><span class="line">        Number of clients running queries: 150</span><br><span class="line">        Average number of queries per client: 0</span><br></pre></td></tr></table></figure><h2 id="多轮测试"><a href="#多轮测试" class="headerlink" title="多轮测试"></a>多轮测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=10 -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Average number of seconds to run all queries: 5.398 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 4.313 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 6.265 seconds</span><br><span class="line">        Number of clients running queries: 150</span><br><span class="line">        Average number of queries per client: 0</span><br></pre></td></tr></table></figure><h2 id="存储引擎测试"><a href="#存储引擎测试" class="headerlink" title="存储引擎测试"></a>存储引擎测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=innodb -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine innodb</span><br><span class="line">        Average number of seconds to run all queries: 5.911 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 5.485 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 6.703 seconds</span><br><span class="line">        Number of clients running queries: 150</span><br><span class="line">        Average number of queries per client: 0</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\zaw&gt;mysqlslap --auto-generate-sql --concurrency=150 --iterations=3 --engine=myisam -uroot -proot</span><br><span class="line">mysqlslap: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Benchmark</span><br><span class="line">        Running for engine myisam</span><br><span class="line">        Average number of seconds to run all queries: 53.104 seconds</span><br><span class="line">        Minimum number of seconds to run all queries: 46.843 seconds</span><br><span class="line">        Maximum number of seconds to run all queries: 60.781 seconds</span><br><span class="line">        Number of clients running queries: 150</span><br><span class="line">        Average number of queries per client: 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;为什么要优化，优化原因&quot;&gt;&lt;a href=&quot;#为什么要优化，优化原因&quot; class=&quot;headerlink&quot; title=&quot;为什么要优化，优化原因&quot;&gt;&lt;/a&gt;为什么要优化，优化原因&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;系统的吞吐量瓶颈往往出现在数据库的访问速度上&lt;/li&gt;
&lt;li&gt;随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢&lt;/li&gt;
&lt;li&gt;数据是存放在磁盘上的，读写速度无法和内存相比&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="Mysql" scheme="https://LiuHuAshen.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>服务器当中数据库的备份</title>
    <link href="https://liuhuashen.github.io/2019/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BD%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD/"/>
    <id>https://liuhuashen.github.io/2019/12/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BD%93%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD/</id>
    <published>2019-12-27T01:53:33.000Z</published>
    <updated>2019-12-27T02:45:43.223Z</updated>
    
    <content type="html"><![CDATA[<p>一：找到Mysql所在位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis mysql</span><br></pre></td></tr></table></figure><p>二：进入到mysql的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/bin</span><br></pre></td></tr></table></figure><p>三、导出数据<br>1.导出表和结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -uroot -proot --set-gtid-purged=OFF halodb  &gt; ~/halodb.sql</span><br></pre></td></tr></table></figure><p>2.只导出结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 -d 数据库名 &gt; 数据库名.sql</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一：找到Mysql所在位置&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="服务器" scheme="https://LiuHuAshen.github.io/tags/服务器/"/>
    
    <category term="数据备份" scheme="https://LiuHuAshen.github.io/tags/数据备份/"/>
    
  </entry>
  
  <entry>
    <title>Redis为什么那么快？</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F/</id>
    <published>2019-12-27T01:52:45.000Z</published>
    <updated>2019-12-27T01:53:01.766Z</updated>
    
    <content type="html"><![CDATA[<p>1、redis基于内存</p><p>2、单线程</p><p>3、多路IO复用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、redis基于内存&lt;/p&gt;
&lt;p&gt;2、单线程&lt;/p&gt;
&lt;p&gt;3、多路IO复用&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>SpringData</title>
    <link href="https://liuhuashen.github.io/2019/12/27/SpringData/"/>
    <id>https://liuhuashen.github.io/2019/12/27/SpringData/</id>
    <published>2019-12-27T01:51:49.000Z</published>
    <updated>2019-12-27T02:45:33.737Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Data :Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。</p><p>SpringData 项目所支持 NoSQL 存储：</p><ul><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ul><p>SpringData 项目所支持的关系数据存储技术：</p><ul><li>JDBC</li><li>JPA</li><li>JPA Spring Data 概述</li><li>JPA Spring Data : 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！</li></ul><p>框架怎么可能代替开发者实现业务逻辑呢？</p><p>比如：当有一个 UserDao.findUserById() 这样一个方法声明，我们大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象，框架根据方法名也知道要做什么，Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><p>SpringData JPA HelloWorld<br>使用 Spring Data JPA 进行持久层开发需要的四个步骤：</p><p>配置 Spring 整合 JPA<br>笔记使用的是SpringBoot配置，配置不重要，重要的是核心内容。</p><p>如果使用SpringBoot配置如下：只需要导入依赖并且填写application.yml文件即可</p><a id="more"></a><p>依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--SpringDataJPA的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--MySQL驱动的依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/springdatajpa?serverTimezone=Asia/Shanghai</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.generate-ddl=true</span><br><span class="line">spring.jpa.show-sql=true</span><br><span class="line">spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect</span><br></pre></td></tr></table></figure><p>注意，如果配置文件中不添加：</p><p>spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect</p><p>则会造成下面的情况，注意下面的SQL语句创建的是MyISAM引擎的数据表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table cst_customer (cust_id bigint not null auto_increment, cust_address varchar(255), cust_industry varchar(255), cust_level varchar(255), cust_name varchar(255), cust_phone varchar(255), cust_source varchar(255), primary key (cust_id)) engine=MyISAM</span><br></pre></td></tr></table></figure><p>添加spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect后，就变成了InnoDB引擎:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hibernate: create table cst_customer (cust_id bigint not null auto_increment, cust_address varchar(255), cust_industry varchar(255), cust_level varchar(255), cust_name varchar(255), cust_phone varchar(255), cust_source varchar(255), primary key (cust_id)) engine=InnoDB</span><br></pre></td></tr></table></figure><p>spring.jpa.database-platform配置的是数据库的方言</p><p>以下是原生方式搭建SpringDataJPA，可以跳到开始开发</p><p>如果使用默认的Spring配置文件的方式，需要先掌握一些JPA的配置规范，百度上到处都有教程，大致步骤如下：</p><p>搭建环境：</p><p>同时下载 Spring Data Commons 和 Spring Data JPA 两个发布包：<br>Commons 是 Spring Data 的基础包<br>并把相关的依赖 JAR 文件加入到 CLASSPATH 中</p><p>在Spring 配置文件中配置 Spring Data，让 Spring为声明的接口创建代理对象。配置了<a href="jpa:repositories" target="_blank" rel="noopener">jpa:repositories</a>后，Spring 初始化容器时将会扫描 base-package 指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring自动封装的特性来直接使用该对象。</p><p>声明持久层的接口，该接口继承 Repository，Repository是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口（通常我们也是实现其他接口），其中定义了一些常用的增删改查，以及分页相关的方法。</p><p>在接口中声明需要的方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</p><p>开始开发<br>写一个实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.example.application.model;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import javax.persistence.*;</span><br><span class="line">@Entity</span><br><span class="line">@Table(name = &quot;cst_customer&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Customer &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    @Column(name = &quot;cust_id&quot;)</span><br><span class="line">    private Long custId;</span><br><span class="line">    @Column(name = &quot;cust_address&quot;)</span><br><span class="line">    private String custAddress;</span><br><span class="line">    @Column(name = &quot;cust_industry&quot;)</span><br><span class="line">    private String custIndustry;</span><br><span class="line">    @Column(name = &quot;cust_level&quot;)</span><br><span class="line">    private String custLevel;</span><br><span class="line">    @Column(name = &quot;cust_name&quot;)</span><br><span class="line">    private String custName;</span><br><span class="line">    @Column(name = &quot;cust_phone&quot;)</span><br><span class="line">    private String custPhone;</span><br><span class="line">    @Column(name = &quot;cust_source&quot;)</span><br><span class="line">    private String custSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实体类使用了Lombok</p><p>类上面的注解解释</p><p>@Entity: 标识该实体类是一个JPA实体类</p><p>@Table: 用来规定该实体类在数据库中所对应的的表的一些特性</p><p>@Data:Lombok注解用来生成getter，setter，toString，hashCode，equals等方法</p><p>@Id:标识该字段为数据表记录中的Id字段</p><p>@GeneratedValue:主见的生成策略，上面的strategy = GenerationType.IDENTITY意思是使用主键自增的方式来控制主键</p><p>@Column:用来映射该属性和数据表中字段名</p><p>写一个Repository接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.example.application.repository;</span><br><span class="line">import com.example.application.model.Customer;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line">public interface CustomerRepository extends JpaRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor&lt;Customer&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的Repository接口继承了两个接口JpaRepository和JpaSpecificationExecutor</p><p>这两个接口中都定义了很多的方法，接口上要规定泛型</p><p>T：表示该Repository要操作的实体类的类型</p><p>ID：表示该Repository控制的实体类的ID是什么类型</p><p>Repository接口的解释<br>Repository 接口是 Spring Data 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.data.repository;</span><br><span class="line">import org.springframework.stereotype.Indexed;</span><br><span class="line">@Indexed</span><br><span class="line">public interface Repository&lt;T, ID&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Data可以让我们只定义接口，只要遵循 Spring Data的规范，就无需写实现类。</p><p>与继承Repository等价的一种方式，就是在持久层接口上使用@RepositoryDefinition 注解，并为其指定 domainClass 和 idClass 属性。</p><p>Repository的子接口<br>基础的 Repository 提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。</p><p>它们的继承关系如下： Repository： 仅仅是一个标识，表明任何继承它的均为仓库接口类 CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法 PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法 JpaRepository： 继承 PagingAndSortingRepository，实现一组 JPA 规范相关的方法 自定义的 XxxxRepository 需要继承 JpaRepository，这样的 XxxxRepository 接口就具备了通用的数据访问控制层的能力。 JpaSpecificationExecutor： 不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</p><p>SpringDataJPA的方法定义规范<br>简单条件查询: 查询某一个实体类或者集合</p><p>按照 Spring Data 的规范，查询方法以 find | read | get开头， 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写。</p><p>例如：定义一个 Entity 实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class User &#123;</span><br><span class="line">private String firstName;</span><br><span class="line">private String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用And条件连接时，应这样写：</p><p>findByLastNameAndFirstName(String lastName,String firstName);</p><p>条件的属性名称与个数要与参数的位置与个数一一对应</p><p>直接在接口中定义查询方法，如果是符合规范的，可以不用写实现，目前支持的关键字写法如下：</p><p>支持的查询关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Logical keywordKeyword expressions</span><br><span class="line">ANDAnd</span><br><span class="line">OROr</span><br><span class="line">AFTERAfter, IsAfter</span><br><span class="line">BEFOREBefore, IsBefore</span><br><span class="line">CONTAININGContaining, IsContaining, Contains</span><br><span class="line">BETWEENBetween, IsBetween</span><br><span class="line">ENDING_WITHEndingWith, IsEndingWith, EndsWith</span><br><span class="line">EXISTSExists</span><br><span class="line">FALSEFalse, IsFalse</span><br><span class="line">GREATER_THANGreaterThan, IsGreaterThan</span><br><span class="line">GREATER_THAN_EQUALSGreaterThanEqual, IsGreaterThanEqual</span><br><span class="line">INIn, IsIn</span><br><span class="line">ISIs, Equals, (or no keyword)</span><br><span class="line">IS_EMPTYIsEmpty, Empty</span><br><span class="line">IS_NOT_EMPTYIsNotEmpty, NotEmpty</span><br><span class="line">IS_NOT_NULLNotNull, IsNotNull</span><br><span class="line">IS_NULLNull, IsNull</span><br><span class="line">LESS_THANLessThan, IsLessThan</span><br><span class="line">LESS_THAN_EQUALLessThanEqual, IsLessThanEqual</span><br><span class="line">LIKELike, IsLike</span><br><span class="line">NEARNear, IsNear</span><br><span class="line">NOTNot, IsNot</span><br><span class="line">NOT_INNotIn, IsNotIn</span><br><span class="line">NOT_LIKENotLike, IsNotLike</span><br><span class="line">REGEXRegex, MatchesRegex, Matches</span><br><span class="line">STARTING_WITHStartingWith, IsStartingWith, StartsWith</span><br><span class="line">TRUETrue, IsTrue</span><br><span class="line">WITHINWithin, IsWithin</span><br></pre></td></tr></table></figure><p>SpringDataJPA对查询关键字的解析步骤<br>假如创建如下的查询：</p><p>findByUserDepUuid();</p><p>框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析，假设查询实体为Doc 先判断 userDepUuid （根据 POJO 规范，首字母变为小写）是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</p><p>从右往左截取第一个大写字母开头的字符串(此处为Uuid)，然后检查剩下的字符串是否为查询实体的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，则重复第二步，继续从右往左截取；最后假设 user 为查询实体的一个属性；</p><p>接着处理剩下部分（DepUuid），先判断 user 所对应的类型是否有depUuid属性，如果有，则表示该方法最终是根据 “ Doc.user.depUuid” 的取值进行查询；否则继续按照步骤 2 的规则从右往左截取，最终表示根据 “Doc.user.dep.uuid” 的值进行查询。</p><p>可能会存在一种特殊情况，比如 Doc包含一个 user 的属性，也有一个 userDep 属性，此时会存在混淆。可以明确在属性之间加上 “_” 以显式表达意图，比如 “findByUser_DepUuid()” 或者 “findByUserDep_uuid()” 特殊的参数： 还可以直接在方法的参数上加入分页或排序的参数，比如：</p><p>Page<usermodel> findByName(String name, Pageable pageable);<br>List<usermodel> findByName(String name, Sort sort);</usermodel></usermodel></p><p>使用 @Query 注解<br>这种查询可以声明在 Repository 方法中，摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明，结构更为清晰，这是 Spring data 的特有实现。</p><p>上面的代码使用的是JPQL语法，下面会说。</p><p>上面的?1是一个参数占位符，对于参数占位符来说，有索引参数和命名参数</p><p>索引参数如上所示，索引值从1开始，查询中 ”?X” 个数需要与方法定义的参数个数相一致，并且顺序也要一致</p><p>命名参数（推荐使用这种方式）：可以定义好参数名，赋值时采用@Param(“参数名”)，而不用管顺序。</p><p>如果是@Query 中有 LIKE 关键字，后面的参数需要前面或者后面加 %，这样在传递参数值的时候就可以不加 %：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;select o from UserModel o where o.name like ?1%&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br><span class="line">@Query(&quot;select o from UserModel o where o.name like %?1&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br><span class="line">@Query(&quot;select o from UserModel o where o.name like %?1%&quot;)</span><br><span class="line">public List&lt;UserModel&gt; findByUuidOrAge(String name);</span><br></pre></td></tr></table></figure><p>重点：还可以使用@Query来指定本地查询，只要设置nativeQuery为true，比如：</p><p>@Query(value=”select * from tbl_user where name like %?1” ,nativeQuery=true)<br>public List<usermodel> findByUuidOrAge(String name);</usermodel></p><p>@Modifying 注解和事务<br>@Query 与 @Modifying 这两个 annotation一起声明，可定义个性化更新操作，例如只涉及某些字段更新时最为常用，示例如下：</p><p>注意： 方法的返回值应该是 int，表示更新语句所影响的行数 在调用的地方必须加事务，没有事务不能正常执行</p><p>事务<br>Spring Data提供了默认的事务处理方式，即所有的查询均声明为只读事务。</p><p>对于自定义的方法，如需改变 Spring Data 提供的事务默认方式，可以在方法上注解 @Transactional 声明</p><p>进行多个 Repository 操作时，也应该使它们在同一个事务中处理，按照分层架构的思想，这部分属于业务逻辑层，因此，需要在 Service 层实现对多个 Repository 的调用，并在相应的方法上声明事务。</p><p>对于Repository接口的具体说明<br>CrudRepository 接口提供了最基本的对实体类的添删改查操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">T save(T entity);//保存单个实体</span><br><span class="line">Iterable save(Iterable&lt;? extends T&gt; entities);//保存集合</span><br><span class="line">T findOne(ID id);//根据id查找实体</span><br><span class="line">boolean exists(ID id);//根据id判断实体是否存在</span><br><span class="line">Iterable findAll();//查询所有实体,不用或慎用!</span><br><span class="line">long count();//查询实体数量</span><br><span class="line">void delete(ID id);//根据Id删除实体</span><br><span class="line">void delete(T entity);//删除一个实体</span><br><span class="line">void delete(Iterable&lt;? extends T&gt; entities);//删除一个实体的集合</span><br><span class="line">void deleteAll();//删除所有实体,不用或慎用!</span><br><span class="line">PagingAndSortingRepository接口提供了分页与排序功能</span><br><span class="line"></span><br><span class="line">Iterable findAll(Sort sort); //排序</span><br><span class="line">Page findAll(Pageable pageable); //分页查询（含排序功能）</span><br><span class="line">JpaRepository接口提供了JPA的相关功能</span><br><span class="line"></span><br><span class="line">List findAll(); //查找所有实体</span><br><span class="line">List findAll(Sort sort); //排序、查找所有实体</span><br><span class="line">List save(Iterable&lt;? extends T&gt; entities);//保存集合</span><br><span class="line">void flush();//执行缓存与数据库同步</span><br><span class="line">T saveAndFlush(T entity);//强制执行持久化</span><br><span class="line">void deleteInBatch(Iterable entities);//删除一个实体集合</span><br><span class="line">JpaSpecificationExecutor接口</span><br><span class="line"></span><br><span class="line">不属于Repository体系，实现一组 JPA Criteria 查询相关的方法</span><br><span class="line"></span><br><span class="line">public interface JpaSpecificationExecutor&lt;T&gt; &#123;</span><br><span class="line">Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Pageable pageable);</span><br><span class="line">List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; spec, Sort sort);</span><br><span class="line">long count(@Nullable Specification&lt;T&gt; spec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Specification：封装 JPA Criteria 查询条件。通常使用匿名内部类的方式来创建该接口的对象，Specification接口中有一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder criteriaBuilder);</span><br></pre></td></tr></table></figure><p>其中的root是用来进行属性导航的，比如说实体类中有一个属性是username，用root来导航到这个username，需要像下面这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.get(&quot;username&quot;).as(String.class);</span><br></pre></td></tr></table></figure><p>JPQL查询语法<br>假设有一个实体类User，实体类中有两个属性username和password</p><p>查询全部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from User;</span><br></pre></td></tr></table></figure><p>查询结果按照username倒序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from User order by username desc;</span><br></pre></td></tr></table></figure><p>统计查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(username) from User;</span><br></pre></td></tr></table></figure><p>分页和条件查询:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Query(&quot;SELECT DISTINCT u FROM User u where u.username = ?1&quot;)</span><br><span class="line">public List&lt;User&gt; findByUsername(String username, Pageable pageable);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Spring Data :Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。&lt;/p&gt;
&lt;p&gt;SpringData 项目所支持 NoSQL 存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MongoDB （文档数据库）&lt;/li&gt;
&lt;li&gt;Neo4j（图形数据库）&lt;/li&gt;
&lt;li&gt;Redis（键/值存储）&lt;/li&gt;
&lt;li&gt;Hbase（列族数据库）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SpringData 项目所支持的关系数据存储技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDBC&lt;/li&gt;
&lt;li&gt;JPA&lt;/li&gt;
&lt;li&gt;JPA Spring Data 概述&lt;/li&gt;
&lt;li&gt;JPA Spring Data : 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;框架怎么可能代替开发者实现业务逻辑呢？&lt;/p&gt;
&lt;p&gt;比如：当有一个 UserDao.findUserById() 这样一个方法声明，我们大致应该能判断出这是根据给定条件的 ID 查询出满足条件的 User 对象，框架根据方法名也知道要做什么，Spring Data JPA 做的便是规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。&lt;/p&gt;
&lt;p&gt;SpringData JPA HelloWorld&lt;br&gt;使用 Spring Data JPA 进行持久层开发需要的四个步骤：&lt;/p&gt;
&lt;p&gt;配置 Spring 整合 JPA&lt;br&gt;笔记使用的是SpringBoot配置，配置不重要，重要的是核心内容。&lt;/p&gt;
&lt;p&gt;如果使用SpringBoot配置如下：只需要导入依赖并且填写application.yml文件即可&lt;/p&gt;</summary>
    
    
    
    
    <category term="SpringData" scheme="https://LiuHuAshen.github.io/tags/SpringData/"/>
    
  </entry>
  
  <entry>
    <title>java连接redis不成功的问题</title>
    <link href="https://liuhuashen.github.io/2019/12/27/java%E8%BF%9E%E6%8E%A5redis%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://liuhuashen.github.io/2019/12/27/java%E8%BF%9E%E6%8E%A5redis%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-12-27T01:50:43.000Z</published>
    <updated>2019-12-28T05:40:44.962Z</updated>
    
    <content type="html"><![CDATA[<p>主要注意</p><p>1）ip和端口号不正确</p><p>2）虚拟机中防火墙的原因（可能性较大）</p><p>3）redis.conf 中bind 127.0.0.1 未用#注释掉</p><p>4）未取消保护模式</p><p>在第一和第二种情况都正确的情况下仍然连接不了，则修改redis.conf文件<br>1)打开配置文件把下面对应的注释掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bind 127.0.0.1</span><br></pre></td></tr></table></figure><p>2)Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure><p>3)保护模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><p>4)最后关键的是：<br>没反应应该是你启动服务端的时候没有带上配置文件。可以redis-server redis.conf</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主要注意&lt;/p&gt;
&lt;p&gt;1）ip和端口号不正确&lt;/p&gt;
&lt;p&gt;2）虚拟机中防火墙的原因（可能性较大）&lt;/p&gt;
&lt;p&gt;3）redis.conf 中bind 127.0.0.1 未用#注释掉&lt;/p&gt;
&lt;p&gt;4）未取消保护模式&lt;/p&gt;
&lt;p&gt;在第一和第二种情况都正确的情况下仍然连</summary>
      
    
    
    
    
    <category term="springboot" scheme="https://LiuHuAshen.github.io/tags/springboot/"/>
    
    <category term="redis" scheme="https://LiuHuAshen.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的五种数据类型</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-12-27T01:50:01.000Z</published>
    <updated>2019-12-27T01:50:17.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h2><h3 id="第一种类型：String-Key-Value"><a href="#第一种类型：String-Key-Value" class="headerlink" title="第一种类型：String Key-Value"></a>第一种类型：String Key-Value</h3><p>set key value  设置一个key 值为 value </p><p>get key  获得key值得value<br>incr key      —对应的value 自增1,如果没有这个key值 自动给你创建创建 并赋值为1</p><p>decr key     —对应的value 自减1</p><h3 id="第二种类型：Hash：key-filed-value"><a href="#第二种类型：Hash：key-filed-value" class="headerlink" title="第二种类型：Hash：key-filed-value"></a>第二种类型：Hash：key-filed-value</h3><p>相当于一个Key就是一个map<br><img src="http://182.92.102.146/upload/2019/12/image-4a7b5ffe1a9642268cf19e78ad48a521.png" alt="image.png"><br>hset key filed value 设置值</p><p>hget key filed 　获取值</p><h3 id="第三种类型：List"><a href="#第三种类型：List" class="headerlink" title="第三种类型：List"></a>第三种类型：List</h3><p>　List 有顺序可重复</p><p>　lpush list 1  2  3  4 从左添加元素　</p><p>  rpush list 1 2 3 4    从右添加元素</p><p>  lrange list 0 -1 (从0 到-1 元素查看：也就表示查看所有)</p><p>  lpop list （从左边取，删除）</p><p>  rpop list  (从右边取，删除)</p><h3 id="第四种类型-：Set"><a href="#第四种类型-：Set" class="headerlink" title="第四种类型 ：Set"></a>第四种类型 ：Set</h3><p>Set 无顺序，不能重复　　　</p><p>sadd set1 a b c d d (向set1中添加元素) 元素不重复</p><p>smembers set1 （查询元素）</p><p>srem set1 a （删除元素）</p><h3 id="第五种类型：SortedSet（zset）"><a href="#第五种类型：SortedSet（zset）" class="headerlink" title="第五种类型：SortedSet（zset）"></a>第五种类型：SortedSet（zset）</h3><p>有顺序，不能重复，适合做排行榜 排序需要一个分数属性</p><p>zrange zset1 0 -1 (从小到大)</p><p>zrevrange zset1 0 -1 (从大到小)</p><p>zincrby zset2 score member (对元素member 增加 score)</p><h2 id="Key命令"><a href="#Key命令" class="headerlink" title="Key命令"></a>Key命令</h2><p>expire key second  (设置key的过期时间)</p><p>ttl key (查看剩余时间)（-2 表示不存在，-1 表示已被持久化，正数表示剩余的时间）</p><p>persist key (清除过期时间，也即是持久化 持久化成功体提示 1 不成功0)。</p><p>del key: 删除key  </p><p>select 0 表示：选择0号数据库。默认是0号数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;五种数据类型&quot;&gt;&lt;a href=&quot;#五种数据类型&quot; class=&quot;headerlink&quot; title=&quot;五种数据类型&quot;&gt;&lt;/a&gt;五种数据类型&lt;/h2&gt;&lt;h3 id=&quot;第一种类型：String-Key-Value&quot;&gt;&lt;a href=&quot;#第一种类型：String-Ke</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的持久化</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2019-12-27T01:49:18.000Z</published>
    <updated>2020-10-22T03:06:25.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis提供了两个不同形式的持久化方式"><a href="#Redis提供了两个不同形式的持久化方式" class="headerlink" title="Redis提供了两个不同形式的持久化方式"></a>Redis提供了两个不同形式的持久化方式</h3><h4 id="1、RDB（redis-of-Database）"><a href="#1、RDB（redis-of-Database）" class="headerlink" title="1、RDB（redis of Database）"></a>1、RDB（redis of Database）</h4><p>在指定的时间间隔内将内存的数据集快照（状态）写入磁盘，恢复是将快照文件直接读到内存里。RDB的方式要AOF更加高效。<br>优点：</p><ul><li>节省磁盘空间</li><li>恢复速度快</li></ul><p>缺点：</p><ul><li>虽然在fork是使用了写时拷贝技术，但是如果数据庞大时还是比较消耗性能。</li><li>最后一次持久化后的数据可能丢失。<h4 id="2、AOF（Append-of-file）"><a href="#2、AOF（Append-of-file）" class="headerlink" title="2、AOF（Append of file）"></a>2、AOF（Append of file）</h4>以日志的形式来记录每个写操作。每秒更新。</li></ul><p>RDB和AOF同时使用的话，Redis更倾向于AOF。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Redis提供了两个不同形式的持久化方式&quot;&gt;&lt;a href=&quot;#Redis提供了两个不同形式的持久化方式&quot; class=&quot;headerlink&quot; title=&quot;Redis提供了两个不同形式的持久化方式&quot;&gt;&lt;/a&gt;Redis提供了两个不同形式的持久化方式&lt;/h3&gt;&lt;</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的主从复制</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2019-12-27T01:48:34.000Z</published>
    <updated>2019-12-27T01:48:54.102Z</updated>
    
    <content type="html"><![CDATA[<p>Master以写为主，Slave以读为主</p><p>用处：</p><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p>步骤<br><img src="http://182.92.102.146/upload/2019/12/image-5b2c6c31e6804617b86f5cc96cf8046a.png" alt="image.png"></p><p>语法：<br>打印主从复制的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure><p>成为某个实例的从服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Master以写为主，Slave以读为主&lt;/p&gt;
&lt;p&gt;用处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读写分离，性能扩展&lt;/li&gt;
&lt;li&gt;容灾快速恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;步骤&lt;br&gt;&lt;img src=&quot;http://182.92.102.146/upload/2019/12</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的哨兵模式（sentinel）</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89/</id>
    <published>2019-12-27T01:47:19.000Z</published>
    <updated>2019-12-27T01:48:03.430Z</updated>
    
    <content type="html"><![CDATA[<p>首先了解什么是反客为主：就是如果主机宕掉了，从机替代主机的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br></pre></td></tr></table></figure><p>反客为主的自动版，能够监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。</p><p><strong>哨兵的配置</strong></p><p>1、配置一主二仆</p><p>2、在redis目录下新建sentinel.conf文件</p><p>3、在配置文件中填写内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>其中mymaster为监控对象起的服务器名称，1为至少有1个哨兵同意迁移的数量</p><p>4、启动哨兵<br>执行redis-sentinel /myredis/sentinel.conf</p><p>故障恢复</p><p><strong>新主登基</strong></p><p>选择条件</p><p>1、选择优先级靠前的</p><p>2、选择偏移量最大的（数据最全）</p><p>3、选择runid最小的从服务</p><p><strong>群仆俯首</strong></p><p><strong>旧主俯首</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先了解什么是反客为主：就是如果主机宕掉了，从机替代主机的位置。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群</title>
    <link href="https://liuhuashen.github.io/2019/12/27/Redis%E9%9B%86%E7%BE%A4/"/>
    <id>https://liuhuashen.github.io/2019/12/27/Redis%E9%9B%86%E7%BE%A4/</id>
    <published>2019-12-27T01:46:16.000Z</published>
    <updated>2019-12-27T01:46:30.875Z</updated>
    
    <content type="html"><![CDATA[<p><strong>优点：</strong><br>Redis集群实现了对Redis的水平扩容<br>分摊压力<br>无中心配置相对简单</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br&gt;Redis集群实现了对Redis的水平扩容&lt;br&gt;分摊压力&lt;br&gt;无中心配置相对简单&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://LiuHuAshen.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
